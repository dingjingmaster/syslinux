     1                                  ; -*- fundamental -*- (asm-mode sucks)
     2                                  ; $Id: ldlinux.asm,v 1.60 2000/11/17 20:46:13 hpa Exp $
     3                                  ; ****************************************************************************
     4                                  ;
     5                                  ;  ldlinux.asm
     6                                  ;
     7                                  ;  A program to boot Linux kernels off an MS-DOS formatted floppy disk.	 This
     8                                  ;  functionality is good to have for installation floppies, where it may
     9                                  ;  be hard to find a functional Linux system to run LILO off.
    10                                  ;
    11                                  ;  This program allows manipulation of the disk to take place entirely
    12                                  ;  from MS-LOSS, and can be especially useful in conjunction with the
    13                                  ;  umsdos filesystem.
    14                                  ;
    15                                  ;  This file is loaded in stages; first the boot sector at offset 7C00h,
    16                                  ;  then the first sector (cluster, really, but we can only assume 1 sector)
    17                                  ;  of LDLINUX.SYS at 7E00h and finally the remainder of LDLINUX.SYS at 8000h.
    18                                  ;
    19                                  ;   Copyright (C) 1994-2000  H. Peter Anvin
    20                                  ;
    21                                  ;  This program is free software; you can redistribute it and/or modify
    22                                  ;  it under the terms of the GNU General Public License as published by
    23                                  ;  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
    24                                  ;  USA; either version 2 of the License, or (at your option) any later
    25                                  ;  version; incorporated herein by reference.
    26                                  ; 
    27                                  ; ****************************************************************************
    28                                  
    29                                  ;
    30                                  ; Some semi-configurable constants... change on your own risk.  Most are imposed
    31                                  ; by the kernel.
    32                                  ;
    33                                  max_cmd_len	equ 255			; Must be odd; 255 is the kernel limit
    34                                  retry_count	equ 6			; How patient are we with the disk?
    35                                  HIGHMEM_MAX	equ 038000000h		; Highest address for an initrd
    36                                  DEFAULT_BAUD	equ 9600		; Default baud rate for serial port
    37                                  BAUD_DIVISOR	equ 115200		; Serial port parameter
    38                                  ;
    39                                  ; Should be updated with every release to avoid bootsector/SYS file mismatch
    40                                  ;
    41                                  %define	version_str	VERSION		; Must be 4 characters long!
    42                                  %define date		DATE_STR	; Defined from the Makefile
    43                                  %define	year		'2000'
    44                                  ;
    45                                  ; Debgging stuff
    46                                  ;
    47                                  ; %define debug 1			; Uncomment to enable debugging
    48                                  ;
    49                                  ; ID for SYSLINUX (reported to kernel)
    50                                  ;
    51                                  syslinux_id	equ 031h		; SYSLINUX (3) version 1.x (1)
    52                                  ;
    53                                  ; Segments used by Linux
    54                                  ;
    55                                  ; Note: the real_mode_seg is supposed to be 9000h, but some device drivers
    56                                  ; hog some of high memory.  Therefore, we load it at 7000:0000h and copy
    57                                  ; it before starting the Linux kernel.
    58                                  ;
    59                                  real_mode_seg	equ 7000h
    60                                  fake_setup_seg	equ real_mode_seg+020h
    61                                  
    62                                  		struc real_mode_seg_t
    63 00000000 <res 20h>               		resb 20h-($-$$)		; org 20h
    64 00000020 ????                    kern_cmd_magic	resw 1			; 0020 Magic # for command line
    65 00000022 ????                    kern_cmd_offset resw 1			; 0022 Offset for kernel command line
    66 00000024 <res 1CDh>              		resb 497-($-$$)		; org 497d
    67 000001F1 ??                      bs_setupsecs	resb 1			; 01F1 Sectors for setup code (0 -> 4)
    68 000001F2 ????                    bs_rootflags	resw 1			; 01F2 Root readonly flag
    69 000001F4 ????                    bs_syssize	resw 1			; 01F4
    70 000001F6 ????                    bs_swapdev	resw 1			; 01F6 Swap device (obsolete)
    71 000001F8 ????                    bs_ramsize	resw 1			; 01F8 Ramdisk flags, formerly ramdisk size
    72 000001FA ????                    bs_vidmode	resw 1			; 01FA Video mode
    73 000001FC ????                    bs_rootdev	resw 1			; 01FC Root device
    74 000001FE ????                    bs_bootsign	resw 1			; 01FE Boot sector signature (0AA55h)
    75 00000200 ??                      su_jump		resb 1			; 0200 0EBh
    76 00000201 ??                      su_jump2	resb 1			; 0201 Size of following header
    77 00000202 ????????                su_header	resd 1			; 0202 New setup code: header
    78 00000206 ????                    su_version	resw 1			; 0206 See linux/arch/i386/boot/setup.S
    79 00000208 ????                    su_switch	resw 1			; 0208
    80 0000020A ????                    su_setupseg	resw 1			; 020A
    81 0000020C ????                    su_startsys	resw 1			; 020C
    82 0000020E ????                    su_kver		resw 1			; 020E Kernel version pointer
    83 00000210 ??                      su_loader	resb 1			; 0210 Loader ID
    84 00000211 ??                      su_loadflags	resb 1			; 0211 Load high flag
    85 00000212 ????                    su_movesize	resw 1			; 0212
    86 00000214 ????????                su_code32start	resd 1			; 0214 Start of code loaded high
    87 00000218 ????????                su_ramdiskat	resd 1			; 0218 Start of initial ramdisk
    88                                  su_ramdisklen	equ $			; Length of initial ramdisk
    89 0000021C ????                    su_ramdisklen1	resw 1			; 021C
    90 0000021E ????                    su_ramdisklen2	resw 1			; 021E
    91 00000220 ????                    su_bsklugeoffs	resw 1			; 0220
    92 00000222 ????                    su_bsklugeseg	resw 1			; 0222
    93 00000224 ????                    su_heapend	resw 1			; 0224
    94 00000226 ????                    su_pad1		resw 1			; 0226
    95 00000228 ????????                su_cmd_line_ptr	resd 1			; 0228
    96 0000022C <res 8DC8h>             		resb (9000h-12)-($-$$)	; The setup is up to 32K long
    97                                  linux_stack	equ $			; 8FF4
    98                                  linux_fdctab	equ $
    99 00008FF4 <res Ch>                		resb 9000h-($-$$)
   100                                  cmd_line_here	equ $			; 9000 Should be out of the way
   101                                  		endstruc
   102                                  
   103                                  ;
   104                                  ; Kernel command line signature
   105                                  ;
   106                                  CMD_MAGIC	equ 0A33Fh		; Command line magic
   107                                  
   108                                  ;
   109                                  ; Magic number of su_header field
   110                                  ;
   111                                  HEADER_ID       equ 'HdrS'		; HdrS (in littleendian hex)
   112                                  
   113                                  ;
   114                                  ; Flags for the su_loadflags field
   115                                  ;
   116                                  LOAD_HIGH	equ 01h			; Large kernel, load high
   117                                  CAN_USE_HEAP    equ 80h                 ; Boot loader reports heap size
   118                                  
   119                                  ;
   120                                  ; The following structure is used for "virtual kernels"; i.e. LILO-style
   121                                  ; option labels.  The options we permit here are `kernel' and `append
   122                                  ; Since there is no room in the bottom 64K for all of these, we
   123                                  ; stick them at vk_seg:0000 and copy them down before we need them.
   124                                  ;
   125                                  ; Note: this structure can be added to, but it must 
   126                                  ;
   127                                  %define vk_power	7		; log2(max number of vkernels)
   128                                  %define	max_vk		(1 << vk_power)	; Maximum number of vkernels
   129                                  %define vk_shift	(16-vk_power)	; Number of bits to shift
   130                                  %define vk_size		(1 << vk_shift)	; Size of a vkernel buffer
   131                                  
   132                                  		struc vkernel
   133 00000000 <res Bh>                vk_vname:	resb 11			; Virtual name **MUST BE FIRST!**
   134 0000000B <res Bh>                vk_rname:	resb 11			; Real name
   135 00000016 ????                    vk_appendlen:	resw 1
   136                                  		alignb 4
   137 00000018 <res 100h>              vk_append:	resb max_cmd_len+1	; Command line
   138                                  		alignb 4
   139                                  vk_end:		equ $			; Should be <= vk_size
   140                                  		endstruc
   141                                  
   142                                  %if (vk_end > vk_size) || (vk_size*max_vk > 65536)
   143                                  %error "Too many vkernels defined, reduce vk_power"
   144                                  %endif
   145                                  
   146                                  ;
   147                                  ; Segment assignments in the bottom 640K
   148                                  ; Stick to the low 512K in case we're using something like M-systems flash
   149                                  ; which load a driver into low RAM (evil!!)
   150                                  ;
   151                                  ; 0000h - main code/data segment (and BIOS segment)
   152                                  ; 7000h - real_mode_seg
   153                                  ;
   154                                  fat_seg		equ 5000h		; 128K area for FAT (2x64K)
   155                                  vk_seg          equ 4000h		; This is where we stick'em
   156                                  xfer_buf_seg	equ 3000h		; Bounce buffer for I/O to high mem
   157                                  comboot_seg	equ 2000h		; COMBOOT image loading zone
   158                                  
   159                                  ;
   160                                  ; For our convenience: define macros for jump-over-unconditinal jumps
   161                                  ;
   162                                  %macro	jmpz	1
   163                                  	jnz %%skip
   164                                  	jmp %1
   165                                  %%skip:
   166                                  %endmacro
   167                                  
   168                                  %macro	jmpnz	1
   169                                  	jz %%skip
   170                                  	jmp %1
   171                                  %%skip:
   172                                  %endmacro
   173                                  
   174                                  %macro	jmpe	1
   175                                  	jne %%skip
   176                                  	jmp %1
   177                                  %%skip:
   178                                  %endmacro
   179                                  
   180                                  %macro	jmpne	1
   181                                  	je %%skip
   182                                  	jmp %1
   183                                  %%skip:
   184                                  %endmacro
   185                                  
   186                                  %macro	jmpc	1
   187                                  	jnc %%skip
   188                                  	jmp %1
   189                                  %%skip:
   190                                  %endmacro
   191                                  
   192                                  %macro	jmpnc	1
   193                                  	jc %%skip
   194                                  	jmp %1
   195                                  %%skip:
   196                                  %endmacro
   197                                  
   198                                  %macro	jmpb	1
   199                                  	jnb %%skip
   200                                  	jmp %1
   201                                  %%skip:
   202                                  %endmacro
   203                                  
   204                                  %macro	jmpnb	1
   205                                  	jb %%skip
   206                                  	jmp %1
   207                                  %%skip:
   208                                  %endmacro
   209                                  
   210                                  ;
   211                                  ; Macros similar to res[bwd], but which works in the code segment (after
   212                                  ; section .text)
   213                                  ;
   214                                  %macro	zb	1
   215                                  	times %1 db 0
   216                                  %endmacro
   217                                  
   218                                  %macro	zw	1
   219                                  	times %1 dw 0
   220                                  %endmacro
   221                                  
   222                                  %macro	zd	1
   223                                  	times %1 dd 0
   224                                  %endmacro
   225                                  
   226                                  ; ---------------------------------------------------------------------------
   227                                  ;   BEGIN THE BIOS/CODE/DATA SEGMENT
   228                                  ; ---------------------------------------------------------------------------
   229                                  		absolute 4*1Eh		; In the interrupt table
   230                                  fdctab		equ $
   231 00000078 ????                    fdctab1		resw 1
   232 0000007A ????                    fdctab2		resw 1
   233                                  
   234                                  %ifdef debug
   235                                  		org 0100h
   236                                  ..start:	
   237                                  ;
   238                                  ; Hook for debugger stuff.  This gets automatically removed when
   239                                  ; generating the real thing.
   240                                  ;
   241                                  ; Initialize the registers for debugger operation
   242                                  ;
   243                                  		cli
   244                                  		mov ax,cs
   245                                  		mov ds,ax
   246                                  		mov es,ax
   247                                  		mov ss,ax
   248                                  		mov sp,StackBuf
   249                                  		sti
   250                                  		cld
   251                                  ;
   252                                  ; Load the actual boot sector so we can copy the data block
   253                                  ;
   254                                  		xor ax,ax		; Reset floppy
   255                                  		xor dx,dx
   256                                  		int 13h
   257                                  		mov cx,6		; Retry count...
   258                                  debug_tryloop:	push cx
   259                                  		mov bx,trackbuf
   260                                  		mov cx,0001h
   261                                  		xor dx,dx
   262                                  		mov ax,0201h
   263                                  		int 13h
   264                                  		pop cx
   265                                  		jnc debug_okay
   266                                  		loop debug_tryloop
   267                                  		int 3			; Halt! (Breakpoint)
   268                                  debug_okay:	mov si,trackbuf+0bh
   269                                  		mov di,bsBytesPerSec
   270                                  		mov cx,33h
   271                                  		rep movsb
   272                                  ;
   273                                  ; Save bogus "BIOS floppy block" info to the stack in case we hit kaboom
   274                                  ;
   275                                  		push si
   276                                  		push si
   277                                  		push si			; Writing to the trackbuf is harmless
   278                                  ;
   279                                  ; Copy the BIOS data area
   280                                  ;
   281                                                  push ds
   282                                                  xor ax,ax
   283                                                  mov ds,ax
   284                                                  mov si,0400h
   285                                                  mov di,si
   286                                                  mov cx,0100h
   287                                                  rep movsw
   288                                                  pop ds
   289                                  ;
   290                                  ;
   291                                  ; A NOP where we can breakpoint, then jump into the code *after*
   292                                  ; the segment register initialization section
   293                                  ;
   294                                  		nop
   295                                  		jmp debugentrypt
   296                                  %endif
   297                                  		absolute 0400h
   298 00000400 ????????????????        serial_base	resw 4			; Base addresses for 4 serial ports
   299                                  
   300                                                  absolute 0484h
   301 00000484 ??                      BIOS_vidrows    resb 1			; Number of screen rows
   302                                  
   303                                  ;
   304                                  ; Memory below this point is reserved for the BIOS and the MBR
   305                                  ;
   306                                   		absolute 1000h
   307                                  trackbuf	equ $			; Track buffer goes here
   308                                  trackbufsize	equ 16384		; Safe size of track buffer
   309                                  ;		trackbuf ends at 5000h
   310                                  
   311                                                  absolute 6000h          ; Here we keep our BSS stuff
   312                                  StackBuf	equ $			; Start the stack here (grow down - 4K)
   313 00006000 <res 200h>              VKernelBuf:	resb vk_size		; "Current" vkernel
   314                                  		alignb 4
   315 00006200 <res 100h>              AppendBuf       resb max_cmd_len+1	; append=
   316 00006300 <res 100h>              KbdMap		resb 256		; Keyboard map
   317 00006400 <res A0h>               FKeyName	resb 10*16		; File names for F-key help
   318 000064A0 <res 10h>               NumBuf		resb 16			; Buffer to load number
   319                                  NumBufEnd	equ NumBuf+15		; Pointer to last byte in NumBuf
   320                                  		alignb 4
   321 000064B0 <res 10h>               PartInfo	resb 16			; Partition table entry
   322 000064C0 ????????                InitRDat	resd 1			; Load address (linear) for initrd
   323 000064C4 ????????                HiLoadAddr      resd 1			; Address pointer for high load loop
   324 000064C8 ????????                HighMemSize	resd 1			; End of memory pointer (bytes)
   325 000064CC ????????                KernelSize	resd 1			; Size of kernel (bytes)
   326 000064D0 <res Ch>                KernelName      resb 12		        ; Mangled name for kernel
   327                                  					; (note the spare byte after!)
   328                                  RootDir		equ $			; Location of root directory
   329 000064DC ????                    RootDir1	resw 1
   330 000064DE ????                    RootDir2	resw 1
   331                                  DataArea	equ $			; Location of data area
   332 000064E0 ????                    DataArea1	resw 1
   333 000064E2 ????                    DataArea2	resw 1
   334                                  FBytes		equ $			; Used by open/getc
   335 000064E4 ????                    FBytes1		resw 1
   336 000064E6 ????                    FBytes2		resw 1
   337 000064E8 ????                    RootDirSize	resw 1			; Root dir size in sectors
   338 000064EA ????                    DirScanCtr	resw 1			; Used while searching directory
   339 000064EC ????                    DirBlocksLeft	resw 1			; Ditto
   340 000064EE ????                    EndofDirSec	resw 1			; = trackbuf+bsBytesPerSec-31
   341 000064F0 ????                    RunLinClust	resw 1			; Cluster # for LDLINUX.SYS
   342 000064F2 ????                    ClustSize	resw 1			; Bytes/cluster
   343 000064F4 ????                    SecPerClust	resw 1			; Same as bsSecPerClust, but a word
   344 000064F6 ????                    NextCluster	resw 1			; Pointer to "nextcluster" routine
   345 000064F8 ????                    BufSafe		resw 1			; Clusters we can load into trackbuf
   346 000064FA ????                    BufSafeSec	resw 1			; = how many sectors?
   347 000064FC ????                    BufSafeBytes	resw 1			; = how many bytes?
   348 000064FE ????                    EndOfGetCBuf	resw 1			; = getcbuf+BufSafeBytes
   349 00006500 ????                    KernelClust	resw 1			; Kernel size in clusters
   350 00006502 ????                    InitRDClust	resw 1			; Ramdisk size in clusters
   351 00006504 ????                    ClustPerMoby	resw 1			; Clusters per 64K
   352 00006506 ????                    FClust		resw 1			; Number of clusters in open/getc file
   353 00006508 ????                    FNextClust	resw 1			; Pointer to next cluster in d:o
   354 0000650A ????                    FPtr		resw 1			; Pointer to next char in buffer
   355 0000650C ????                    CmdOptPtr       resw 1			; Pointer to first option on cmd line
   356 0000650E ????                    KernelCNameLen  resw 1			; Length of unmangled kernel name
   357 00006510 ????                    InitRDCNameLen  resw 1			; Length of unmangled initrd name
   358 00006512 ????                    NextCharJump    resw 1			; Routine to interpret next print char
   359 00006514 ????                    SetupSecs	resw 1			; Number of setup sectors
   360 00006516 ????                    SavedSP		resw 1			; Our SP while running a COMBOOT image
   361 00006518 ????                    A20Test		resw 1			; Counter for testing status of A20
   362 0000651A ????                    CmdLineLen	resw 1			; Length of command line including null
   363                                  TextAttrBX      equ $
   364 0000651C ??                      TextAttribute   resb 1			; Text attribute for message file
   365 0000651D ??                      TextPage        resb 1			; Active display page
   366                                  CursorDX        equ $
   367 0000651E ??                      CursorCol       resb 1			; Cursor column for message file
   368 0000651F ??                      CursorRow       resb 1			; Cursor row for message file
   369                                  ScreenSize      equ $
   370 00006520 ??                      VidCols         resb 1			; Columns on screen-1
   371 00006521 ??                      VidRows         resb 1			; Rows on screen-1
   372 00006522 ??                      RetryCount      resb 1			; Used for disk access retries
   373 00006523 ??                      KbdFlags	resb 1			; Check for keyboard escapes
   374 00006524 ??                      LoadFlags	resb 1			; Loadflags from kernel
   375 00006525 ??                      A20Tries	resb 1			; Times until giving up on A20
   376 00006526 ??                      A20KBCflag	resb 1			; Did we use KBC to access A20?
   377 00006527 ??                      FuncFlag	resb 1			; Escape sequences received from keyboard
   378 00006528 <res Bh>                MNameBuf        resb 11            	; Generic mangled file name buffer
   379 00006533 <res Bh>                InitRD          resb 11                 ; initrd= mangled name
   380 0000653E <res Dh>                KernelCName     resb 13                 ; Unmangled kernel name
   381 0000654B <res Dh>                InitRDCName     resb 13            	; Unmangled initrd name
   382                                  
   383                                  		section .text
   384                                                  org 7C00h
   385                                  ;
   386                                  ; Primary entry point.  Tempting as though it may be, we can't put the
   387                                  ; initial "cli" here; the jmp opcode in the first byte is part of the
   388                                  ; "magic number" (using the term very loosely) for the DOS superblock.
   389                                  ;
   390                                  bootsec		equ $
   391 00000000 EB3C                    		jmp short start		; 2 bytes
   392 00000002 90                      		nop			; 1 byte
   393                                  ;
   394                                  ; "Superblock" follows -- it's in the boot sector, so it's already
   395                                  ; loaded and ready for us
   396                                  ;
   397 00000003 5359534C494E5558        bsOemName	db 'SYSLINUX'		; The SYS command sets this, so...
   398                                  superblock	equ $
   399                                  bsBytesPerSec	zw 1
   399                              <1> bsBytesPerSec :
   219 0000000B 0000                <1>  times %1 dw 0
   400                                  bsSecPerClust	zb 1
   400                              <1> bsSecPerClust :
   215 0000000D 00                  <1>  times %1 db 0
   401                                  bsResSectors	zw 1
   401                              <1> bsResSectors :
   219 0000000E 0000                <1>  times %1 dw 0
   402                                  bsFATs		zb 1
   402                              <1> bsFATs :
   215 00000010 00                  <1>  times %1 db 0
   403                                  bsRootDirEnts	zw 1
   403                              <1> bsRootDirEnts :
   219 00000011 0000                <1>  times %1 dw 0
   404                                  bsSectors	zw 1
   404                              <1> bsSectors :
   219 00000013 0000                <1>  times %1 dw 0
   405                                  bsMedia		zb 1
   405                              <1> bsMedia :
   215 00000015 00                  <1>  times %1 db 0
   406                                  bsFATsecs	zw 1
   406                              <1> bsFATsecs :
   219 00000016 0000                <1>  times %1 dw 0
   407                                  bsSecPerTrack	zw 1
   407                              <1> bsSecPerTrack :
   219 00000018 0000                <1>  times %1 dw 0
   408                                  bsHeads		zw 1
   408                              <1> bsHeads :
   219 0000001A 0000                <1>  times %1 dw 0
   409                                  bsHiddenSecs	equ $
   410                                  bsHidden1	zw 1
   410                              <1> bsHidden1 :
   219 0000001C 0000                <1>  times %1 dw 0
   411                                  bsHidden2	zw 1
   411                              <1> bsHidden2 :
   219 0000001E 0000                <1>  times %1 dw 0
   412                                  bsHugeSectors	equ $
   413                                  bsHugeSec1	zw 1
   413                              <1> bsHugeSec1 :
   219 00000020 0000                <1>  times %1 dw 0
   414                                  bsHugeSec2	zw 1
   414                              <1> bsHugeSec2 :
   219 00000022 0000                <1>  times %1 dw 0
   415                                  bsDriveNumber	zb 1
   415                              <1> bsDriveNumber :
   215 00000024 00                  <1>  times %1 db 0
   416                                  bsReserved1	zb 1
   416                              <1> bsReserved1 :
   215 00000025 00                  <1>  times %1 db 0
   417                                  bsBootSignature zb 1			; 29h if the following fields exist
   417                              <1> bsBootSignature :
   215 00000026 00                  <1>  times %1 db 0
   418                                  bsVolumeID	zd 1
   418                              <1> bsVolumeID :
   223 00000027 00000000            <1>  times %1 dd 0
   419                                  bsVolumeLabel	zb 11
   419                              <1> bsVolumeLabel :
   215 0000002B 00<rep Bh>          <1>  times %1 db 0
   420                                  bsFileSysType	zb 8			; Must be FAT12 for this version
   420                              <1> bsFileSysType :
   215 00000036 00<rep 8h>          <1>  times %1 db 0
   421                                  superblock_len	equ $-superblock
   422                                  ;
   423                                  ; Note we don't check the constraints above now; we did that at install
   424                                  ; time (we hope!)
   425                                  ;
   426                                  
   427                                  ;floppy_table	equ $			; No sense in wasting memory, overwrite start
   428                                  
   429                                  start:
   430 0000003E FA                      		cli			; No interrupts yet, please
   431 0000003F FC                      		cld			; Copy upwards
   432                                  ;
   433                                  ; Set up the stack
   434                                  ;
   435 00000040 31C9                    		xor cx,cx
   436 00000042 8ED1                    		mov ss,cx
   437 00000044 BC0060                  		mov sp,StackBuf		; Just below BSS
   438 00000047 8EC1                    		mov es,cx
   439                                  ;
   440                                  ; DS:SI may contain a partition table entry.  Preserve it for us.
   441                                  ;
   442 00000049 B108                    		mov cl,8		; Save partition info (CH == 0)
   443 0000004B BFB064                  		mov di,PartInfo
   444 0000004E F3A5                    		rep movsw
   445                                  ;
   446                                  ; Now sautee the BIOS floppy info block to that it will support decent-
   447                                  ; size transfers; the floppy block is 11 bytes and is stored in the
   448                                  ; INT 1Eh vector (brilliant waste of resources, eh?)
   449                                  ;
   450                                  ; Of course, if BIOSes had been properly programmed, we wouldn't have
   451                                  ; had to waste precious boot sector space with this code.
   452                                  ;
   453                                  ; This code no longer fits.  Hope that noone really needs it anymore.
   454                                  ; (If so, it needs serious updating.)  In fact, some indications is that
   455                                  ; this code does more harm than good with all the new kinds of drives and
   456                                  ; media.
   457                                  ;
   458                                  %ifdef SUPPORT_REALLY_BROKEN_BIOSES
   459                                  		lds si,[ss:fdctab]	; DS:SI -> original
   460                                  		push ds			; Save on stack in case
   461                                  		push si			; we have to bail
   462                                  		push bx
   463                                  		mov cx,6		; 12 bytes
   464                                  		mov di,floppy_table
   465                                  		push di
   466                                  		cld
   467                                  		rep movsw		; Faster to move words
   468                                  		pop di
   469                                  		mov ds,ax		; Now we can point DS to here, too
   470                                  		mov cl,[bsSecPerTrack]  ; Patch the sector count
   471                                  		mov [di+4],cl
   472                                  		mov [fdctab+2],ax	; Segment 0
   473                                  		mov [fdctab],di		; offset floppy_block
   474                                  %else
   475 00000050 8ED9                    		mov ds,cx		; CX == 0
   476                                  %endif
   477                                  ;
   478                                  ; Ready to enable interrupts, captain
   479                                  ;
   480 00000052 FB                      		sti
   481                                  ;
   482                                  ; The drive number and possibly partition information was passed to us
   483                                  ; by the BIOS or previous boot loader (MBR).  Current "best practice" is to
   484                                  ; trust that rather than what the superblock contains.
   485                                  ;
   486                                  ; Would it be better to zero out bsHidden if we don't have a partition table?
   487                                  ;
   488                                  ; Note: di points to beyond the end of PartInfo
   489                                  ;
   490 00000053 8816[2400]              		mov [bsDriveNumber],dl
   491 00000057 F6C280                  		test dl,80h		; If floppy disk (00-7F), assume no
   492 0000005A 7427                    		jz not_harddisk		; partition table
   493 0000005C F645F07F                		test byte [di-16],7Fh	; Sanity check: "active flag" should
   494 00000060 750A                    		jnz no_partition	; be 00 or 80
   495 00000062 8D75F8                  		lea si,[di-8]		; Partition offset (dword)
   496 00000065 BF[1C00]                		mov di,bsHidden1
   497 00000068 B102                    		mov cl,2		; CH == 0
   498 0000006A F3A5                    		rep movsw
   499                                  no_partition:
   500                                  ;
   501                                  ; Get disk drive parameters (don't trust the superblock.)  Don't do this for
   502                                  ; floppy drives -- INT 13:08 on floppy drives will (may?) return info about
   503                                  ; what the *drive* supports, not about the *media*.  Fortunately floppy disks
   504                                  ; tend to have a fixed, well-defined geometry which is stored in the superblock.
   505                                  ;
   506                                  		; DL == drive # still
   507 0000006C B408                    		mov ah,08h
   508 0000006E CD13                    		int 13h
   509 00000070 7211                    		jc no_driveparm
   510 00000072 20E4                    		and ah,ah
   511 00000074 750D                    		jnz no_driveparm
   512 00000076 FEC6                    		inc dh			; Contains # of heads - 1
   513 00000078 8836[1A00]              		mov [bsHeads],dh
   514 0000007C 83E13F                  		and cx,3fh
   515 0000007F 890E[1800]              		mov [bsSecPerTrack],cx
   516                                  no_driveparm:
   517                                  not_harddisk:
   518                                  ;
   519                                  ; Now we have to do some arithmetric to figure out where things are located.
   520                                  ; If Micro$oft had had brains they would already have done this for us,
   521                                  ; and stored it in the superblock at format time, but here we go,
   522                                  ; wasting precious boot sector space again...
   523                                  ;
   524                                  debugentrypt:
   525 00000083 31C0                    		xor ax,ax		; INT 13:08 destroys ES
   526 00000085 8EC0                    		mov es,ax
   527 00000087 A0[1000]                		mov al,[bsFATs]		; Number of FATs (AH == 0)
   528 0000008A F726[1600]              		mul word [bsFATsecs]	; Get the size of the FAT area
   529 0000008E 0306[1C00]              		add ax,[bsHidden1]	; Add hidden sectors
   530 00000092 1316[1E00]              		adc dx,[bsHidden2]
   531 00000096 0306[0E00]              		add ax,[bsResSectors]	; And reserved sectors
   532 0000009A 83D200                  		adc dx,byte 0
   533                                  
   534 0000009D A3DC64                  		mov [RootDir1],ax	; Location of root directory
   535 000000A0 8916DE64                		mov [RootDir2],dx
   536 000000A4 A3E064                  		mov [DataArea1],ax
   537 000000A7 8916E264                		mov [DataArea2],dx
   538 000000AB 50                      		push ax
   539 000000AC 52                      		push dx
   540                                  
   541 000000AD B82000                  		mov ax,32		; Size of a directory entry
   542 000000B0 F726[1100]              		mul word [bsRootDirEnts]
   543 000000B4 8B1E[0B00]              		mov bx,[bsBytesPerSec]
   544 000000B8 01D8                    		add ax,bx		; Round up, not down
   545 000000BA 48                      		dec ax
   546 000000BB F7F3                    		div bx			; Now we have the size of the root dir
   547 000000BD A3E864                  		mov [RootDirSize],ax
   548 000000C0 A3EA64                  		mov [DirScanCtr],ax
   549 000000C3 81C3E10F                		add bx,trackbuf-31
   550 000000C7 891EEE64                		mov [EndofDirSec],bx	; End of a single directory sector
   551                                  
   552 000000CB 0106E064                		add [DataArea1],ax
   553 000000CF 8316E26400              		adc word [DataArea2],byte 0
   554                                  
   555 000000D4 5A                      		pop dx			; Reload root directory starting point
   556 000000D5 58                      		pop ax
   557                                  ;
   558                                  ; Now the fun begins.  We have to search the root directory for
   559                                  ; LDLINUX.SYS and load the first sector, so we have a little more
   560                                  ; space to have fun with.  Then we can go chasing through the FAT.
   561                                  ; Joy!!
   562                                  ;
   563 000000D6 50                      sd_nextsec:	push ax
   564 000000D7 52                      		push dx
   565 000000D8 BB0010                  		mov bx,trackbuf
   566 000000DB 53                      		push bx
   567 000000DC E88F00                  		call getonesec
   568 000000DF 5E                      		pop si
   569 000000E0 803C00                  sd_nextentry:	cmp byte [si],0		; Directory high water mark
   570 000000E3 7429                    		je kaboom
   571 000000E5 F6440B18                		test byte [si+11],18h	; Must be a file
   572 000000E9 750C                    		jnz sd_not_file
   573 000000EB BF[EF01]                		mov di,ldlinux_name
   574 000000EE B90B00                  		mov cx,11
   575 000000F1 56                      		push si
   576 000000F2 F3A6                    		repe cmpsb
   577 000000F4 5E                      		pop si
   578 000000F5 742D                    		je found_it
   579 000000F7 83C620                  sd_not_file:	add si,byte 32		; Distance to next
   580 000000FA 3B36EE64                		cmp si,[EndofDirSec]
   581 000000FE 72E0                    		jb sd_nextentry
   582 00000100 5A                      		pop dx
   583 00000101 58                      		pop ax
   584 00000102 83C001                  		add ax,byte 1
   585 00000105 83D200                  		adc dx,byte 0
   586 00000108 FF0EEA64                		dec word [DirScanCtr]
   587 0000010C 75C8                    		jnz sd_nextsec
   588                                  ;
   589                                  ; kaboom: write a message and bail out.
   590                                  ;
   591                                  kaboom:
   592 0000010E 31F6                    		xor si,si
   593 00000110 8ED6                    		mov ss,si		
   594 00000112 BC0060                  		mov sp,StackBuf 	; Reset stack
   595 00000115 8EDE                    		mov ds,si		; Reset data segment
   596 00000117 BE[DD01]                .patch:		mov si,bailmsg
   597 0000011A E83900                  		call writestr		; Returns with AL = 0
   598 0000011D 98                      		cbw			; AH <- 0
   599 0000011E CD16                    		int 16h			; Wait for keypress
   600 00000120 CD19                    		int 19h			; And try once more to boot...
   601 00000122 EBFE                    .norge:		jmp short .norge	; If int 19h returned; this is the end
   602                                  
   603                                  ;
   604                                  ; found_it: now we compute the location of the first sector, then
   605                                  ;	    load it and JUMP (since we're almost out of space)
   606                                  ;
   607                                  found_it:	; Note: we actually leave two words on the stack here
   608                                  		; (who cares?)
   609 00000124 31C0                    		xor ax,ax
   610 00000126 A0[0D00]                		mov al,[bsSecPerClust]
   611 00000129 89C5                    		mov bp,ax		; Load an entire cluster
   612 0000012B 8B5C1A                  		mov bx,[si+26]		; First cluster
   613 0000012E 891EF064                		mov [RunLinClust],bx	; Save for later use
   614 00000132 4B                      		dec bx			; First cluster is "cluster 2"
   615 00000133 4B                      		dec bx
   616 00000134 F7E3                    		mul bx
   617 00000136 0306E064                		add ax,[DataArea1]
   618 0000013A 1316E264                		adc dx,[DataArea2]
   619 0000013E BB[0002]                		mov bx,ldlinux_sys
   620 00000141 E82D00                  		call getlinsec
   621 00000144 BE[EF01]                		mov si,bs_magic
   622 00000147 BF[1F02]                		mov di,ldlinux_magic
   623 0000014A B91100                  		mov cx,magic_len
   624 0000014D F3A6                    		repe cmpsb		; Make sure that the bootsector
   625 0000014F 75BD                    		jne kaboom		; matches LDLINUX.SYS
   626                                  ;
   627                                  ; Done! Jump to the entry point!
   628                                  ; 
   629                                  ; Note that some BIOSes are buggy and run the boot sector at 07C0:0000
   630                                  ; instead of 0000:7C00 and the like.  We don't want to add anything
   631                                  ; more to the boot sector, so it is written to not assume a fixed
   632                                  ; value in CS, but we don't want to deal with that anymore from now
   633                                  ; on.
   634                                  ;
   635 00000151 EA[3002]0000            		jmp 0:ldlinux_ent
   636                                  
   637                                  ;
   638                                  ;
   639                                  ; writestr: write a null-terminated string to the console
   640                                  ;
   641                                  writestr:
   642 00000156 AC                      wstr_1:         lodsb
   643 00000157 20C0                    		and al,al
   644 00000159 7412                                    jz return
   645 0000015B B40E                    		mov ah,0Eh		; Write to screen as TTY
   646 0000015D BB0700                  		mov bx,0007h		; White on black, current page
   647 00000160 CD10                    		int 10h
   648 00000162 EBF2                    		jmp short wstr_1
   649                                  ;
   650                                  ; disk_error: decrement the retry count and bail if zero
   651                                  ;
   652 00000164 4E                      disk_error:	dec si			; SI holds the disk retry counter
   653 00000165 74A7                    		jz kaboom
   654 00000167 93                      		xchg ax,bx		; Shorter than MOV
   655 00000168 5B                      		pop bx			; <I>
   656 00000169 59                      		pop cx			; <H>
   657 0000016A 5A                      		pop dx			; <G>
   658 0000016B EB3C                    		jmp short disk_try_again
   659                                  
   660 0000016D C3                      return:		ret
   661                                  
   662                                  ;
   663                                  ; getonesec: like getlinsec, but pre-sets the count to 1
   664                                  ;
   665                                  getonesec:
   666 0000016E BD0100                  		mov bp,1
   667                                  		; Fall through to getlinsec
   668                                  
   669                                  ;
   670                                  ; getlinsec: load a sequence of BP floppy sector given by the linear sector
   671                                  ;	     number in DX:AX into the buffer at ES:BX.	We try to optimize
   672                                  ;	     by loading up to a whole track at a time, but the user
   673                                  ;	     is responsible for not crossing a 64K boundary.
   674                                  ;	     (Yes, BP is weird for a count, but it was available...)
   675                                  ;
   676                                  ;	     On return, BX points to the first byte after the transferred
   677                                  ;	     block.
   678                                  ;
   679                                  ;	     The "stupid patch area" gets replaced by the code
   680                                  ;	     mov bp,1 ; nop ... (BD 01 00 90 90...) when installing with
   681                                  ;	     the -s option.
   682                                  ;
   683                                  ; Stylistic note: use "xchg" instead of "mov" when the source is a register
   684                                  ; that is dead from that point; this saves space.  However, please keep
   685                                  ; the order to dst,src to keep things sane.
   686                                  ;
   687                                  getlinsec:
   688 00000171 8B36[1800]              		mov si,[bsSecPerTrack]
   689                                  		;
   690                                  		; Dividing by sectors to get (track,sector): we may have
   691                                  		; up to 2^18 tracks, so we need to do this in two steps
   692                                  		; to produce a 32-bit quotient.
   693                                  		;
   694 00000175 91                      		xchg cx,ax		; CX <- LSW of LBA
   695 00000176 92                      		xchg ax,dx
   696 00000177 31D2                    		xor dx,dx		; DX:AX now == MSW of LBA
   697 00000179 F7F6                    		div si			; Obtain MSW of track #
   698 0000017B 91                      		xchg ax,cx		; Remainder -> MSW of new dividend
   699                                  					; LSW of LBA -> LSW of new dividend
   700                                  					; Quotient -> MSW of track # 
   701 0000017C F7F6                    		div si			; Obtain LSW of track #, remainder
   702 0000017E 87D1                    		xchg cx,dx		; CX <- Sector index (0-based)
   703                                  					; DX <- MSW of track #
   704 00000180 F736[1A00]              		div word [bsHeads]	; Convert track to head/cyl
   705                                  		;
   706                                  		; Now we have AX = cyl, DX = head, CX = sector (0-based),
   707                                  		; BP = sectors to transfer, SI = bsSecPerTrack,
   708                                  		; ES:BX = data target
   709                                  		;
   710 00000184 56                      gls_nextchunk:	push si			; <A> bsSecPerTrack
   711 00000185 55                      		push bp			; <B> Sectors to transfer
   712                                  
   713                                  __BEGIN_STUPID_PATCH_AREA:
   714 00000186 29CE                    		sub si,cx		; Sectors left on track
   715 00000188 39F5                    		cmp bp,si
   716 0000018A 7602                    		jna gls_lastchunk
   717 0000018C 89F5                    		mov bp,si		; No more than a trackful, please!
   718                                  __END_STUPID_PATCH_AREA:
   719                                  gls_lastchunk:	
   720 0000018E 50                      		push ax			; <C> Cylinder #
   721 0000018F 52                      		push dx			; <D> Head #
   722                                  
   723 00000190 51                      		push cx			; <E> Sector #
   724 00000191 B106                    		mov cl,6		; Because IBM was STOOPID
   725 00000193 D2E4                    		shl ah,cl		; and thought 8 bits were enough
   726                                  					; then thought 10 bits were enough...
   727 00000195 59                      		pop cx			; <E> Sector #
   728 00000196 51                      		push cx			; <E> Sector #
   729 00000197 41                      		inc cx			; Sector numbers are 1-based
   730 00000198 08E1                    		or cl,ah
   731 0000019A 88C5                    		mov ch,al
   732 0000019C 88D6                    		mov dh,dl
   733 0000019E 8A16[2400]              		mov dl,[bsDriveNumber]
   734 000001A2 95                      		xchg ax,bp		; Sector to transfer count
   735                                  					; (xchg shorter than mov)
   736 000001A3 50                      		push ax			; <F> Number of sectors we're transferring
   737 000001A4 B402                    		mov ah,02h		; Read it!
   738                                  ;
   739                                  ; Do the disk transfer... save the registers in case we fail :(
   740                                  ;
   741 000001A6 BE0600                  		mov si,retry_count	; # of times to retry a disk access
   742 000001A9 52                      disk_try_again: push dx			; <G>
   743 000001AA 51                      		push cx			; <H>
   744 000001AB 53                      		push bx			; <I>
   745 000001AC 50                      		push ax			; <J>
   746 000001AD 56                      		push si			; <K>
   747 000001AE CD13                    		int 13h
   748 000001B0 5E                      		pop si			; <K>
   749 000001B1 5B                      		pop bx			; <J>
   750 000001B2 72B0                    		jc disk_error
   751                                  ;
   752                                  ; Disk access successful
   753                                  ;
   754 000001B4 5B                      		pop bx			; <I> Buffer location
   755 000001B5 58                      		pop ax			; <H> No longer needed
   756 000001B6 58                      		pop ax			; <G> No longer needed
   757 000001B7 5F                      		pop di			; <F> Sector transferred count
   758 000001B8 59                      		pop cx			; <E> Sector #
   759 000001B9 89F8                    		mov ax,di		; Reduce sector left count
   760 000001BB F726[0B00]              		mul word [bsBytesPerSec] ; Figure out how much to advance ptr
   761 000001BF 01C3                    		add bx,ax		; Update buffer location
   762 000001C1 5A                      		pop dx			; <D> Head #
   763 000001C2 58                      		pop ax			; <C> Cyl #
   764 000001C3 5D                      		pop bp			; <B> Sectors left to transfer
   765 000001C4 5E                      		pop si			; <A> Number of sectors/track
   766 000001C5 29FD                    		sub bp,di		; Reduce with # of sectors just read
   767 000001C7 74A4                    		jz return		; Done!
   768 000001C9 01F9                    		add cx,di
   769 000001CB 39F1                    		cmp cx,si
   770 000001CD 72B5                    		jb gls_nextchunk
   771 000001CF 42                      		inc dx			; Next track on cyl
   772 000001D0 3B16[1A00]              		cmp dx,[bsHeads]	; Was this the last one?
   773 000001D4 7203                    		jb gls_nonewcyl
   774 000001D6 40                      		inc ax			; If so, new cylinder
   775 000001D7 31D2                    		xor dx,dx		; First head on new cylinder
   776 000001D9 29F1                    gls_nonewcyl:	sub cx,si		; First sector on new track
   777 000001DB EBA7                    		jmp short gls_nextchunk
   778                                  
   779 000001DD 426F6F74206661696C-     bailmsg:	db 'Boot failed', 0Dh, 0Ah, 0
   779 000001E6 65640D0A00         
   780                                  
   781                                  bs_checkpt	equ $			; Must be <= 1EFh
   782                                  
   783                                  		zb 1EFh-($-$$)
   215 000001EB 00<rep 4h>          <1>  times %1 db 0
   784                                  bs_magic	equ $			; From here to the magic_len equ
   785                                  					; must match ldlinux_magic
   786 000001EF 4C444C494E55582053-     ldlinux_name:	db 'LDLINUX SYS'	; Looks like this in the root dir
   786 000001F8 5953               
   787 000001FA 01E74B3A                		dd HEXDATE		; Hopefully unique between compiles
   788                                  
   789 000001FE 55AA                    bootsignature	dw 0AA55h
   790                                  magic_len	equ $-bs_magic
   791                                  
   792                                  ;
   793                                  ; ===========================================================================
   794                                  ;  End of boot sector
   795                                  ; ===========================================================================
   796                                  ;  Start of LDLINUX.SYS
   797                                  ; ===========================================================================
   798                                  
   799                                  ldlinux_sys:
   800                                  
   801 00000200 0D0A5359534C494E55-     syslinux_banner	db 0Dh, 0Ah, 'SYSLINUX ', version_str, ' ', date, ' ', 0
   801 00000209 5820312E3531203078-
   801 00000212 336134626537303120-
   801 0000021B 00                 
   802 0000021C 0D0A1A                  		db 0Dh, 0Ah, 1Ah	; EOF if we "type" this in DOS
   803                                  
   804 0000021F 4C444C494E55582053-     ldlinux_magic	db 'LDLINUX SYS'
   804 00000228 5953               
   805 0000022A 01E74B3A                		dd HEXDATE
   806 0000022E 55AA                    		dw 0AA55h
   807                                  
   808                                  		align 4
   809                                  
   810                                  ldlinux_ent:
   811                                  ;
   812                                  ; Tell the user we got this far
   813                                  ;
   814 00000230 BE[0002]                		mov si,syslinux_banner
   815 00000233 E820FF                  		call writestr
   816                                  ;
   817                                  ; Remember, the boot sector loaded only the first cluster of LDLINUX.SYS.
   818                                  ; We can really only rely on a single sector having been loaded.  Hence
   819                                  ; we should load the FAT into RAM and start chasing pointers...
   820                                  ;
   821 00000236 BA0100                  		mov dx,1			; 64K
   822 00000239 31C0                    		xor ax,ax
   823 0000023B F736[0B00]              		div word [bsBytesPerSec]	; sectors/64K
   824 0000023F 89C6                    		mov si,ax
   825                                  
   826 00000241 06                      		push es
   827 00000242 BB0050                  		mov bx,fat_seg			; Load into fat_seg:0000
   828 00000245 8EC3                    		mov es,bx
   829                                  		
   830 00000247 A1[1C00]                		mov ax,[bsHidden1]		; Hidden sectors
   831 0000024A 8B16[1E00]              		mov dx,[bsHidden2]
   832 0000024E 0306[0E00]              		add ax,[bsResSectors]		; plus reserved sectors = FAT
   833 00000252 83D200                  		adc dx,byte 0
   834 00000255 8B0E[1600]              		mov cx,[bsFATsecs]		; Sectors/FAT
   835                                  fat_load_loop:	
   836 00000259 89CD                    		mov bp,cx
   837 0000025B 39F5                    		cmp bp,si
   838 0000025D 7602                    		jna fat_load
   839 0000025F 89F5                    		mov bp,si			; A full 64K moby
   840                                  fat_load:	
   841 00000261 31DB                    		xor bx,bx			; Offset 0 in the current ES
   842 00000263 E82201                  		call getlinsecsr
   843 00000266 29E9                    		sub cx,bp
   844 00000268 740F                    		jz fat_load_done		; Last moby?
   845 0000026A 01E8                    		add ax,bp			; Advance sector count
   846 0000026C 83D200                  		adc dx,byte 0
   847 0000026F 8CC3                    		mov bx,es			; Next 64K moby
   848 00000271 81C30010                		add bx,1000h
   849 00000275 8EC3                    		mov es,bx
   850 00000277 EBE0                    		jmp short fat_load_loop
   851                                  fat_load_done:
   852 00000279 07                      		pop es
   853                                  ;
   854                                  ; Fine, now we have the FAT in memory.	How big is a cluster, really?
   855                                  ; Also figure out how many clusters will fit in an 8K buffer, and how
   856                                  ; many sectors and bytes that is
   857                                  ;
   858 0000027A 8B3E[0B00]              		mov di,[bsBytesPerSec]		; Used a lot below
   859                                  
   860 0000027E A0[0D00]                		mov al,[bsSecPerClust]		; We do this in the boot
   861 00000281 30E4                    		xor ah,ah			; sector, too, but there
   862 00000283 A3F464                  		mov [SecPerClust],ax		; wasn't space to save it
   863 00000286 89C6                    		mov si,ax			; Also used a lot...
   864 00000288 F7E7                    		mul di
   865 0000028A A3F264                  		mov [ClustSize],ax		; Bytes/cluster
   866 0000028D 89C3                    		mov bx,ax
   867 0000028F B80040                  		mov ax,trackbufsize
   868 00000292 31D2                    		xor dx,dx
   869 00000294 F7F3                    		div bx
   870 00000296 A3F864                  		mov [BufSafe],ax		; # of cluster in trackbuf
   871 00000299 F726F464                		mul word [SecPerClust]
   872 0000029D A3FA64                  		mov [BufSafeSec],ax
   873 000002A0 F7E7                    		mul di
   874 000002A2 A3FC64                  		mov [BufSafeBytes],ax
   875 000002A5 050098                  		add ax,getcbuf			; Size of getcbuf is the same
   876 000002A8 A3FE64                  		mov [EndOfGetCBuf],ax		; as for trackbuf
   877                                  ;
   878                                  ; FAT12 or FAT16?  This computation is fscking ridiculous...
   879                                  ;
   880 000002AB 31D2                    		xor dx,dx
   881 000002AD 31C9                    		xor cx,cx
   882 000002AF A1[1300]                		mov ax,[bsSectors]
   883 000002B2 21C0                    		and ax,ax
   884 000002B4 7507                    		jnz have_secs
   885 000002B6 A1[2000]                		mov ax,[bsHugeSectors]
   886 000002B9 8B16[2200]              		mov dx,[bsHugeSectors+2]
   887 000002BD 2B06[0E00]              have_secs:	sub ax,[bsResSectors]
   888 000002C1 83DA00                  		sbb dx,byte 0
   889 000002C4 8A0E[1000]              		mov cl,[bsFATs]
   890 000002C8 2B06[1600]              sec_fat_loop:	sub ax,[bsFATsecs]
   891 000002CC 83DA00                  		sbb dx,byte 0
   892 000002CF E2F7                    		loop sec_fat_loop
   893 000002D1 50                      		push ax
   894 000002D2 52                      		push dx
   895 000002D3 A1[1100]                		mov ax,[bsRootDirEnts]
   896 000002D6 BB2000                  		mov bx,32			; Smaller than shift since we
   897 000002D9 F7E3                    		mul bx				; need the doubleword product
   898 000002DB 01F8                    		add ax,di
   899 000002DD 83D200                  		adc dx,byte 0
   900 000002E0 83E801                  		sub ax,byte 1
   901 000002E3 83DA00                  		sbb dx,byte 0
   902 000002E6 F7F7                    		div di
   903 000002E8 89C3                    		mov bx,ax
   904 000002EA 5A                      		pop dx
   905 000002EB 58                      		pop ax
   906 000002EC 29D8                    		sub ax,bx
   907 000002EE 83DA00                  		sbb dx,byte 0
   908 000002F1 F7F6                    		div si
   909 000002F3 3DF60F                  		cmp ax,4086			; Right value?
   910 000002F6 B8[BF03]                		mov ax,nextcluster_fat16
   911 000002F9 7703                    		ja have_fat_type
   912 000002FB B8[9803]                have_fat12:	mov ax,nextcluster_fat12
   913 000002FE A3F664                  have_fat_type:	mov word [NextCluster],ax
   914                                  
   915                                  ;
   916                                  ; Now we read the rest of LDLINUX.SYS.	Don't bother loading the first
   917                                  ; cluster again, though.
   918                                  ;
   919                                  load_rest:
   920 00000301 8B0EF264                		mov cx,[ClustSize]
   921 00000305 BB[0002]                		mov bx,ldlinux_sys
   922 00000308 01CB                    		add bx,cx
   923 0000030A 8B36F064                		mov si,[RunLinClust]
   924 0000030E FF16F664                		call [NextCluster]
   925 00000312 31D2                    		xor dx,dx
   926 00000314 B83119                  		mov ax,ldlinux_len-1		; To be on the safe side
   927 00000317 01C8                    		add ax,cx
   928 00000319 F7F1                    		div cx				; the number of clusters
   929 0000031B 48                      		dec ax				; We've already read one
   930 0000031C 7405                    		jz all_read_jmp
   931 0000031E 89C1                    		mov cx,ax
   932 00000320 E80300                  		call getfssec
   933                                  ;
   934                                  ; All loaded up
   935                                  ;
   936                                  all_read_jmp:
   937 00000323 E9B000                  		jmp all_read
   938                                  ;
   939                                  ; -----------------------------------------------------------------------------
   940                                  ; Subroutines that have to be in the first sector
   941                                  ; -----------------------------------------------------------------------------
   942                                  ;
   943                                  ; getfssec: Get multiple clusters from a file, given the starting cluster.
   944                                  ;
   945                                  ;	This routine makes sure the subtransfers do not cross a 64K boundary,
   946                                  ;	and will correct the situation if it does, UNLESS *sectors* cross
   947                                  ;	64K boundaries.
   948                                  ;
   949                                  ;	ES:BX	-> Buffer
   950                                  ;	SI	-> Starting cluster number (2-based)
   951                                  ;	CX	-> Cluster count (0FFFFh = until end of file)
   952                                  ;
   953                                  						; 386 check
   954                                  getfssec:
   955 00000326 31ED                    getfragment:	xor bp,bp			; Fragment sector count
   956 00000328 89F0                    		mov ax,si			; Get sector address
   957 0000032A 48                      		dec ax				; Convert to 0-based
   958 0000032B 48                      		dec ax
   959 0000032C F726F464                		mul word [SecPerClust]
   960 00000330 0306E064                		add ax,[DataArea1]
   961 00000334 1316E264                		adc dx,[DataArea2]
   962                                  getseccnt:					; See if we can read > 1 clust
   963 00000338 032EF464                		add bp,[SecPerClust]
   964 0000033C 49                      		dec cx				; Reduce clusters left to find
   965 0000033D 89F7                    		mov di,si			; Predict next cluster
   966 0000033F 47                      		inc di
   967 00000340 FF16F664                		call [NextCluster]
   968 00000344 7207                    		jc gfs_eof			; At EOF?
   969 00000346 E304                    		jcxz endfragment		; Or was it the last we wanted?
   970 00000348 39FE                    		cmp si,di			; Is file continuous?
   971 0000034A 74EC                    		jz getseccnt			; Yes, we can get
   972 0000034C F8                      endfragment:	clc				; Not at EOF
   973 0000034D 9C                      gfs_eof:	pushf				; Remember EOF or not
   974 0000034E 56                      		push si
   975 0000034F 51                      		push cx
   976                                  gfs_getchunk:
   977 00000350 50                      		push ax
   978 00000351 52                      		push dx
   979 00000352 8CC0                    		mov ax,es			; Check for 64K boundaries.
   980 00000354 B104                    		mov cl,4
   981 00000356 D3E0                    		shl ax,cl
   982 00000358 01D8                    		add ax,bx
   983 0000035A 31D2                    		xor dx,dx
   984 0000035C F7D8                    		neg ax
   985 0000035E 7501                    		jnz gfs_partseg
   986 00000360 42                      		inc dx				; Full 64K segment
   987                                  gfs_partseg:
   988 00000361 F736[0B00]              		div word [bsBytesPerSec]	; How many sectors fit?
   989 00000365 89EE                    		mov si,bp
   990 00000367 29C6                    		sub si,ax			; Compute remaining sectors
   991 00000369 7610                    		jbe gfs_lastchunk
   992 0000036B 89C5                    		mov bp,ax
   993 0000036D 5A                      		pop dx
   994 0000036E 58                      		pop ax
   995 0000036F E81600                  		call getlinsecsr
   996 00000372 01E8                    		add ax,bp
   997 00000374 83D200                  		adc dx,byte 0
   998 00000377 89F5                    		mov bp,si			; Remaining sector count
   999 00000379 EBD5                    		jmp short gfs_getchunk
  1000 0000037B 5A                      gfs_lastchunk:	pop dx
  1001 0000037C 58                      		pop ax		
  1002 0000037D E8F1FD                  		call getlinsec
  1003 00000380 59                      		pop cx
  1004 00000381 5E                      		pop si
  1005 00000382 9D                      		popf
  1006 00000383 E302                    		jcxz gfs_return			; If we hit the count limit
  1007 00000385 739F                    		jnc getfragment			; If we didn't hit EOF
  1008 00000387 C3                      gfs_return:	ret
  1009                                  
  1010                                  ;
  1011                                  ; getlinsecsr: save registers, call getlinsec, restore registers
  1012                                  ;
  1013 00000388 50                      getlinsecsr:	push ax
  1014 00000389 52                      		push dx
  1015 0000038A 51                      		push cx
  1016 0000038B 55                      		push bp
  1017 0000038C 56                      		push si
  1018 0000038D 57                      		push di
  1019 0000038E E8E0FD                  		call getlinsec
  1020 00000391 5F                      		pop di
  1021 00000392 5E                      		pop si
  1022 00000393 5D                      		pop bp
  1023 00000394 59                      		pop cx
  1024 00000395 5A                      		pop dx
  1025 00000396 58                      		pop ax
  1026 00000397 C3                      		ret
  1027                                  
  1028                                  ;
  1029                                  ; nextcluster: Advance a cluster pointer in SI to the next cluster
  1030                                  ;	       pointed at in the FAT tables (note: FAT12 assumed)
  1031                                  ;	       Sets CF on return if end of file.
  1032                                  ;
  1033                                  ;	       The variable NextCluster gets set to the appropriate
  1034                                  ;	       value here.
  1035                                  ;
  1036                                  nextcluster_fat12:
  1037 00000398 50                      		push ax
  1038 00000399 1E                      		push ds
  1039 0000039A B80050                  		mov ax,fat_seg
  1040 0000039D 8ED8                    		mov ds,ax
  1041 0000039F 89F0                    		mov ax,si			; Multiply by 3/2
  1042 000003A1 D1E8                    		shr ax,1
  1043 000003A3 9C                      		pushf				; CF now set if odd
  1044 000003A4 01C6                    		add si,ax
  1045 000003A6 8B34                    		mov si,[si]
  1046 000003A8 9D                      		popf
  1047 000003A9 7308                    		jnc nc_even
  1048 000003AB D1EE                    		shr si,1			; Needed for odd only
  1049 000003AD D1EE                    		shr si,1
  1050 000003AF D1EE                    		shr si,1
  1051 000003B1 D1EE                    		shr si,1
  1052                                  nc_even:
  1053 000003B3 81E6FF0F                		and si,0FFFh
  1054 000003B7 81FEF00F                		cmp si,0FF0h			; Clears CF if at end of file
  1055 000003BB F5                      		cmc				; But we want it SET...
  1056 000003BC 1F                      		pop ds
  1057 000003BD 58                      		pop ax
  1058 000003BE C3                      nc_return:	ret
  1059                                  
  1060                                  ;
  1061                                  ; FAT16 decoding routine.  Note that a 16-bit FAT can be up to 128K,
  1062                                  ; so we have to decide if we're in the "low" or the "high" 64K-segment...
  1063                                  ;
  1064                                  nextcluster_fat16:
  1065 000003BF 50                      		push ax
  1066 000003C0 1E                      		push ds
  1067 000003C1 B80050                  		mov ax,fat_seg
  1068 000003C4 D1E6                    		shl si,1
  1069 000003C6 7303                    		jnc .seg0
  1070 000003C8 B80060                  		mov ax,fat_seg+1000h
  1071 000003CB 8ED8                    .seg0:		mov ds,ax
  1072 000003CD 8B34                    		mov si,[si]
  1073 000003CF 83FEF0                  		cmp si,0FFF0h
  1074 000003D2 F5                      		cmc
  1075 000003D3 1F                      		pop ds
  1076 000003D4 58                      		pop ax
  1077 000003D5 C3                      		ret
  1078                                  ;
  1079                                  ; Debug routine
  1080                                  ;
  1081                                  %ifdef debug
  1082                                  safedumpregs:
  1083                                  		cmp word [Debug_Magic],0D00Dh
  1084                                  		jnz nc_return
  1085                                  		jmp dumpregs
  1086                                  %endif
  1087                                  
  1088                                  rl_checkpt	equ $				; Must be <= 400h
  1089                                  
  1090                                  ; ----------------------------------------------------------------------------
  1091                                  ;  End of code and data that have to be in the first sector
  1092                                  ; ----------------------------------------------------------------------------
  1093                                  
  1094                                  all_read:
  1095                                  ;
  1096                                  ; Let the user (and programmer!) know we got this far.  This used to be
  1097                                  ; in Sector 1, but makes a lot more sense here.
  1098                                  ;
  1099 000003D6 BE[C814]                		mov si,copyright_str
  1100 000003D9 E87AFD                  		call writestr
  1101                                  ;
  1102                                  ; Check that no moron is trying to boot Linux on a 286 or so.  According
  1103                                  ; to Intel, the way to check is to see if the high 4 bits of the FLAGS
  1104                                  ; register are either all stuck at 1 (8086/8088) or all stuck at 0
  1105                                  ; (286 in real mode), if not it is a 386 or higher.  They didn't
  1106                                  ; say how to check for a 186/188, so I *hope* it falls out as a 8086
  1107                                  ; or 286 in this test.
  1108                                  ;
  1109                                  ; Also, provide an escape route in case it doesn't work.
  1110                                  ;
  1111                                  check_escapes:
  1112 000003DC B402                    		mov ah,02h			; Check keyboard flags
  1113 000003DE CD16                    		int 16h
  1114 000003E0 A22365                  		mov [KbdFlags],al		; Save for boot prompt check
  1115 000003E3 A804                    		test al,04h			; Ctrl->skip 386 check
  1116 000003E5 7538                    		jnz skip_checks
  1117                                  test_8086:
  1118 000003E7 9C                      		pushf				; Get flags
  1119 000003E8 58                      		pop ax
  1120 000003E9 25FF0F                  		and ax,0FFFh			; Clear top 4 bits
  1121 000003EC 50                      		push ax				; Load into FLAGS
  1122 000003ED 9D                      		popf
  1123 000003EE 9C                      		pushf				; And load back
  1124 000003EF 58                      		pop ax
  1125 000003F0 2500F0                  		and ax,0F000h			; Get top 4 bits
  1126 000003F3 3D00F0                  		cmp ax,0F000h			; If set -> 8086/8088
  1127 000003F6 740E                    		je not_386
  1128                                  test_286:
  1129 000003F8 9C                      		pushf				; Get flags
  1130 000003F9 58                      		pop ax
  1131 000003FA 0D00F0                  		or ax,0F000h			; Set top 4 bits
  1132 000003FD 50                      		push ax
  1133 000003FE 9D                      		popf
  1134 000003FF 9C                      		pushf
  1135 00000400 58                      		pop ax
  1136 00000401 2500F0                  		and ax,0F000h			; Get top 4 bits
  1137 00000404 7509                    		jnz is_386			; If not clear -> 386
  1138                                  not_386:
  1139 00000406 BE[4015]                		mov si,err_not386
  1140 00000409 E84AFD                  		call writestr
  1141 0000040C E9FFFC                  		jmp kaboom
  1142                                  is_386:
  1143                                  		; Now we know it's a 386 or higher
  1144                                  ;
  1145                                  ; Now check that there is at least 512K of low (DOS) memory
  1146                                  ;
  1147 0000040F CD12                    		int 12h
  1148 00000411 3D0002                  		cmp ax,512
  1149 00000414 7309                    		jae enough_ram
  1150 00000416 BE[2D16]                		mov si,err_noram
  1151 00000419 E83AFD                  		call writestr
  1152 0000041C E9EFFC                  		jmp kaboom
  1153                                  enough_ram:
  1154                                  skip_checks:
  1155                                  ;
  1156                                  ; Check if we're 386 (as opposed to 486+); if so we need to blank out
  1157                                  ; the WBINVD instruction
  1158                                  ;
  1159                                  ; We check for 486 by setting EFLAGS.AC
  1160                                  ;
  1161 0000041F 669C                    		pushfd				; Save the good flags
  1162 00000421 669C                    		pushfd
  1163 00000423 6658                    		pop eax
  1164 00000425 6689C3                  		mov ebx,eax
  1165 00000428 663500000400            		xor eax,(1 << 18)		; AC bit
  1166 0000042E 6650                    		push eax
  1167 00000430 669D                    		popfd
  1168 00000432 669C                    		pushfd
  1169 00000434 6658                    		pop eax
  1170 00000436 669D                    		popfd				; Restore the original flags
  1171 00000438 6631D8                  		xor eax,ebx
  1172 0000043B 7505                    		jnz is_486
  1173                                  ;
  1174                                  ; 386 - Looks like we better blot out the WBINVD instruction
  1175                                  ;
  1176 0000043D C606[D20E]C3            		mov byte [try_wbinvd],0c3h		; Near RET		
  1177                                  is_486:
  1178                                  
  1179                                  ;
  1180                                  ; Initialization that does not need to go into the any of the pre-load
  1181                                  ; areas
  1182                                  ;
  1183 00000442 E8BB0B                  		call adjust_screen
  1184                                  ;
  1185                                  ; Now, everything is "up and running"... patch kaboom for more
  1186                                  ; verbosity and using the full screen system
  1187                                  ;
  1188 00000445 C606[1701]E9            		mov byte [kaboom.patch],0e9h		; JMP NEAR
  1189 0000044A C706[1801]ED10          		mov word [kaboom.patch+1],kaboom2-(kaboom.patch+3)
  1190                                  
  1191                                  ;
  1192                                  ; Now we're all set to start with our *real* business.	First load the
  1193                                  ; configuration file (if any) and parse it.
  1194                                  ;
  1195                                  ; In previous versions I avoided using 32-bit registers because of a
  1196                                  ; rumour some BIOSes clobbered the upper half of 32-bit registers at
  1197                                  ; random.  I figure, though, that if there are any of those still left
  1198                                  ; they probably won't be trying to install Linux on them...
  1199                                  ;
  1200                                  ; The code is still ripe with 16-bitisms, though.  Not worth the hassle
  1201                                  ; to take'm out.  In fact, we may want to put them back if we're going
  1202                                  ; to boot ELKS at some point.
  1203                                  ;
  1204 00000450 BE[3819]                		mov si,linuxauto_cmd		; Default command: "linux auto"
  1205 00000453 BF[511A]                		mov di,default_cmd
  1206 00000456 B90B00                                  mov cx,linuxauto_len
  1207 00000459 F3A4                    		rep movsb
  1208                                  
  1209 0000045B BF0063                  		mov di,KbdMap			; Default keymap 1:1
  1210 0000045E 30C0                    		xor al,al
  1211 00000460 B90001                  		mov cx,256
  1212 00000463 AA                      mkkeymap:	stosb
  1213 00000464 FEC0                    		inc al
  1214 00000466 E2FB                    		loop mkkeymap
  1215                                  
  1216                                  ;
  1217                                  ; Load configuration file
  1218                                  ;
  1219 00000468 BF[D318]                		mov di,syslinux_cfg
  1220 0000046B E8A60D                  		call open
  1221 0000046E 0F840D02                		jz near no_config_file
  1222                                  parse_config:
  1223 00000472 E83B0E                  		call getkeyword
  1224 00000475 0F820302                                jc near end_config_file		; Config file loaded
  1225 00000479 3D6465                  		cmp ax,'de'			; DEfault
  1226 0000047C 7449                    		je pc_default
  1227 0000047E 3D6170                  		cmp ax,'ap'			; APpend
  1228 00000481 7454                    		je pc_append
  1229 00000483 3D7469                  		cmp ax,'ti'			; TImeout
  1230 00000486 0F849C00                		je near pc_timeout
  1231 0000048A 3D7072                  		cmp ax,'pr'			; PRompt
  1232 0000048D 0F84B200                		je near pc_prompt
  1233 00000491 3D666F                  		cmp ax,'fo'			; FOnt
  1234 00000494 0F848E01                		je near pc_font
  1235 00000498 3D6B62                  		cmp ax,'kb'			; KBd
  1236 0000049B 0F849101                		je near pc_kbd
  1237 0000049F 3D6469                  		cmp ax,'di'			; DIsplay
  1238 000004A2 0F849200                		je near pc_display
  1239 000004A6 3D6C61                  		cmp ax,'la'			; LAbel
  1240 000004A9 0F844601                		je near pc_label
  1241 000004AD 3D6B65                  		cmp ax,'ke'			; KErnel
  1242 000004B0 745B                    		je pc_kernel
  1243 000004B2 3D696D                                  cmp ax,'im'                     ; IMplicit
  1244 000004B5 0F849500                                je near pc_implicit
  1245 000004B9 3D7365                  		cmp ax,'se'			; SErial
  1246 000004BC 0F849900                		je near pc_serial
  1247 000004C0 3C66                    		cmp al,'f'			; F-key
  1248 000004C2 75AE                    		jne parse_config
  1249 000004C4 E90201                  		jmp pc_fkey
  1250                                  
  1251 000004C7 BF[511A]                pc_default:	mov di,default_cmd		; "default" command
  1252 000004CA E8F20E                  		call getline
  1253 000004CD BE[3E19]                		mov si,auto_cmd			; add "auto"+null
  1254 000004D0 B90500                                  mov cx,auto_len
  1255 000004D3 F3A4                    		rep movsb
  1256 000004D5 EB9B                    		jmp short parse_config
  1257                                  
  1258 000004D7 833E[3019]00            pc_append:      cmp word [VKernelCtr],byte 0	; "append" command
  1259 000004DC 7710                    		ja pc_append_vk
  1260 000004DE BF0062                                  mov di,AppendBuf
  1261 000004E1 E8DB0E                  		call getline
  1262 000004E4 81EF0062                                sub di,AppendBuf
  1263 000004E8 893E[2619]              pc_app1:        mov [AppendLen],di
  1264 000004EC EB84                                    jmp short parse_config
  1265 000004EE BF1860                  pc_append_vk:	mov di,VKernelBuf+vk_append	; "append" command (vkernel)
  1266 000004F1 E8CB0E                  		call getline
  1267 000004F4 81EF1860                		sub di,VKernelBuf+vk_append
  1268 000004F8 83FF02                                  cmp di,byte 2
  1269 000004FB 750A                                    jne pc_app2
  1270 000004FD 803E18602D                              cmp byte [VKernelBuf+vk_append],'-'
  1271 00000502 7503                                    jne pc_app2
  1272 00000504 BF0000                                  mov di,0                        ; If "append -" -> null string
  1273 00000507 893E1660                pc_app2:        mov [VKernelBuf+vk_appendlen],di
  1274 0000050B EB33                    		jmp short parse_config_2	
  1275                                  
  1276 0000050D 833E[3019]00            pc_kernel:	cmp word [VKernelCtr],byte 0	; "kernel" command
  1277 00000512 0F845CFF                		je near parse_config		; ("label" section only)
  1278 00000516 BF0010                  		mov di,trackbuf
  1279 00000519 57                      		push di
  1280 0000051A E8A20E                  		call getline
  1281 0000051D 5E                      		pop si
  1282 0000051E BF0B60                  		mov di,VKernelBuf+vk_rname
  1283 00000521 E8D80E                  		call mangle_name
  1284 00000524 EB1A                    		jmp short parse_config_2
  1285                                  
  1286 00000526 E8E20D                  pc_timeout:	call getint			; "timeout" command
  1287 00000529 7215                    		jc parse_config_2
  1288 0000052B B815D2                  		mov ax,0D215h			; There are approx 1.D215h
  1289 0000052E F7E3                    		mul bx				; clock ticks per 1/10 s
  1290 00000530 01D3                    		add bx,dx
  1291 00000532 891E[2819]              		mov [KbdTimeOut],bx
  1292 00000536 EB08                    		jmp short parse_config_2
  1293                                  
  1294 00000538 E80001                  pc_display:	call pc_getfile			; "display" command
  1295 0000053B 7403                    		jz parse_config_2		; File not found?
  1296 0000053D E8390B                  		call get_msg_file		; Load and display file
  1297 00000540 E92FFF                  parse_config_2: jmp parse_config
  1298                                  
  1299 00000543 E8C50D                  pc_prompt:	call getint			; "prompt" command
  1300 00000546 72F8                    		jc parse_config_2
  1301 00000548 891E[3219]              		mov [ForcePrompt],bx
  1302 0000054C EBF2                    		jmp short parse_config_2
  1303                                  
  1304 0000054E E8BA0D                  pc_implicit:    call getint                     ; "implicit" command
  1305 00000551 72ED                                    jc parse_config_2
  1306 00000553 891E[3419]                              mov [AllowImplicit],bx
  1307 00000557 EBE7                                    jmp short parse_config_2
  1308                                  
  1309 00000559 E8AF0D                  pc_serial:	call getint			; "serial" command
  1310 0000055C 72E2                    		jc parse_config_2
  1311 0000055E 53                      		push bx				; Serial port #
  1312 0000055F E8350D                  		call skipspace
  1313 00000562 72DC                    		jc parse_config_2
  1314 00000564 E81F0D                  		call ungetc
  1315 00000567 E8A10D                  		call getint
  1316 0000056A 7306                    		jnc .valid_baud
  1317 0000056C 66BB80250000            		mov ebx,DEFAULT_BAUD		; No baud rate given
  1318 00000572 5F                      .valid_baud:	pop di				; Serial port #
  1319 00000573 6683FB4B                		cmp ebx,byte 75
  1320 00000577 72C7                    		jb parse_config_2		; < 75 baud == bogus
  1321 00000579 66B800C20100            		mov eax,BAUD_DIVISOR
  1322 0000057F 6699                    		cdq
  1323 00000581 66F7F3                  		div ebx
  1324 00000584 50                      		push ax				; Baud rate divisor
  1325 00000585 89FA                    		mov dx,di
  1326 00000587 D1E7                    		shl di,1
  1327 00000589 8B850004                		mov ax,[di+serial_base]
  1328 0000058D A3[3619]                		mov [SerialPort],ax
  1329 00000590 50                      		push ax				; Serial port base
  1330 00000591 B8E300                  		mov ax,00e3h			; INT 14h init parameters
  1331 00000594 CD14                    		int 14h				; Init serial port
  1332 00000596 5B                      		pop bx				; Serial port base
  1333 00000597 8D5703                  		lea dx,[bx+3]
  1334 0000059A B083                    		mov al,83h			; Enable DLAB
  1335 0000059C E86A08                  		call slow_out
  1336 0000059F 58                      		pop ax				; Divisor
  1337 000005A0 89DA                    		mov dx,bx
  1338 000005A2 E86408                  		call slow_out
  1339 000005A5 42                      		inc dx
  1340 000005A6 88E0                    		mov al,ah
  1341 000005A8 E85E08                  		call slow_out
  1342 000005AB B003                    		mov al,03h			; Disable DLAB
  1343 000005AD 83C202                  		add dx,byte 2
  1344 000005B0 E85608                  		call slow_out
  1345 000005B3 83EA02                  		sub dx,byte 2
  1346 000005B6 30C0                    		xor al,al			; IRQ disable
  1347 000005B8 E84E08                  		call slow_out
  1348                                  
  1349                                  		; Show some life
  1350 000005BB BE[0002]                		mov si,syslinux_banner
  1351 000005BE E8E10B                  		call write_serial_str
  1352 000005C1 BE[C814]                		mov si,copyright_str
  1353 000005C4 E8DB0B                  		call write_serial_str
  1354                                  
  1355 000005C7 EB6F                    		jmp short parse_config_3
  1356                                  
  1357 000005C9 80EC31                  pc_fkey:	sub ah,'1'
  1358 000005CC 7302                    		jnb pc_fkey1
  1359 000005CE B409                    		mov ah,9			; F10
  1360 000005D0 31C9                    pc_fkey1:	xor cx,cx
  1361 000005D2 88E1                    		mov cl,ah
  1362 000005D4 51                      		push cx
  1363 000005D5 B80100                  		mov ax,1
  1364 000005D8 D3E0                    		shl ax,cl
  1365 000005DA 0906[2A19]              		or [FKeyMap], ax		; Mark that we have this loaded
  1366 000005DE BF0010                  		mov di,trackbuf
  1367 000005E1 57                      		push di
  1368 000005E2 E8DA0D                  		call getline			; Get filename to display
  1369 000005E5 5E                      		pop si
  1370 000005E6 5F                      		pop di
  1371 000005E7 C1E704                  		shl di,4			; Multiply number by 16
  1372 000005EA 81C70064                		add di,FKeyName
  1373 000005EE E80B0E                  		call mangle_name		; Mangle file name
  1374 000005F1 EB45                    		jmp short parse_config_3
  1375                                  
  1376 000005F3 E85800                  pc_label:	call commit_vk			; Commit any current vkernel
  1377 000005F6 BF0010                  		mov di,trackbuf			; Get virtual filename
  1378 000005F9 57                      		push di
  1379 000005FA E8C20D                  		call getline
  1380 000005FD 5E                      		pop si
  1381 000005FE BF0060                  		mov di,VKernelBuf+vk_vname
  1382 00000601 E8F80D                  		call mangle_name		; Mangle virtual name
  1383 00000604 FF06[3019]              		inc word [VKernelCtr]		; One more vkernel
  1384 00000608 BE0060                  		mov si,VKernelBuf+vk_vname 	; By default, rname == vname
  1385 0000060B BF0B60                  		mov di,VKernelBuf+vk_rname
  1386 0000060E B90B00                  		mov cx,11
  1387 00000611 F3A4                    		rep movsb
  1388 00000613 BE0062                                  mov si,AppendBuf         	; Default append==global append
  1389 00000616 BF1860                                  mov di,VKernelBuf+vk_append
  1390 00000619 8B0E[2619]                              mov cx,[AppendLen]
  1391 0000061D 890E1660                                mov [VKernelBuf+vk_appendlen],cx
  1392 00000621 F3A4                                    rep movsb
  1393 00000623 E91200                  		jmp near parse_config_3
  1394                                  
  1395 00000626 E81200                  pc_font:	call pc_getfile			; "font" command
  1396 00000629 740D                    		jz parse_config_3		; File not found?
  1397 0000062B E8ED09                  		call loadfont			; Load and install font
  1398 0000062E EB08                    		jmp short parse_config_3
  1399                                  
  1400 00000630 E80800                  pc_kbd:		call pc_getfile			; "kbd" command
  1401 00000633 7403                    		jz parse_config_3
  1402 00000635 E8220A                  		call loadkeys
  1403 00000638 E937FE                  parse_config_3:	jmp parse_config
  1404                                  
  1405                                  ;
  1406                                  ; pc_getfile:	For command line options that take file argument, this
  1407                                  ; 		routine decodes the file argument and runs it through searchdir
  1408                                  ;
  1409 0000063B BF0010                  pc_getfile:	mov di,trackbuf
  1410 0000063E 57                      		push di
  1411 0000063F E87D0D                  		call getline
  1412 00000642 5E                      		pop si
  1413 00000643 BF2865                  		mov di,MNameBuf
  1414 00000646 57                      		push di
  1415 00000647 E8B20D                  		call mangle_name
  1416 0000064A 5F                      		pop di
  1417 0000064B E92F09                  		jmp searchdir			; Tailcall
  1418                                  
  1419                                  ;
  1420                                  ; commit_vk: Store the current VKernelBuf into buffer segment
  1421                                  ;
  1422                                  commit_vk:
  1423 0000064E 833E[3019]00            		cmp word [VKernelCtr],byte 0
  1424 00000653 741F                    		je cvk_ret			; No VKernel = return
  1425 00000655 813E[3019]8000          		cmp word [VKernelCtr],max_vk	; Above limit?
  1426 0000065B 7718                    		ja cvk_overflow
  1427 0000065D 8B3E[3019]              		mov di,[VKernelCtr]
  1428 00000661 4F                      		dec di
  1429 00000662 C1E709                  		shl di,vk_shift
  1430 00000665 BE0060                  		mov si,VKernelBuf
  1431 00000668 B98000                  		mov cx,(vk_size >> 2)
  1432 0000066B 06                      		push es
  1433 0000066C 680040                  		push word vk_seg
  1434 0000066F 07                      		pop es
  1435 00000670 F366A5                  		rep movsd			; Copy to buffer segment
  1436 00000673 07                      		pop es
  1437 00000674 C3                      cvk_ret:	ret
  1438 00000675 C706[3019]8000          cvk_overflow:	mov word [VKernelCtr],max_vk	; No more than max_vk, please
  1439 0000067B C3                      		ret
  1440                                  
  1441                                  ;
  1442                                  ; End of configuration file
  1443                                  ;
  1444                                  end_config_file:
  1445 0000067C E8CFFF                  		call commit_vk			; Commit any current vkernel
  1446                                  no_config_file:
  1447                                  ;
  1448                                  ; Check whether or not we are supposed to display the boot prompt.
  1449                                  ;
  1450                                  check_for_key:
  1451 0000067F 833E[3219]00            		cmp word [ForcePrompt],byte 0	; Force prompt?
  1452 00000684 7509                    		jnz enter_command
  1453 00000686 F60623655B              		test byte [KbdFlags],5Bh	; Caps, Scroll, Shift, Alt
  1454 0000068B 0F84EC00                		jz near auto_boot		; If neither, default boot
  1455                                  
  1456                                  enter_command:
  1457 0000068F BE[F214]                		mov si,boot_prompt
  1458 00000692 E8250B                  		call cwritestr
  1459                                  
  1460 00000695 C606276500              		mov byte [FuncFlag],0		; <Ctrl-F> not pressed
  1461 0000069A BF[5019]                		mov di,command_line
  1462                                  ;
  1463                                  ; get the very first character -- we can either time
  1464                                  ; out, or receive a character press at this time.  Some dorky BIOSes stuff
  1465                                  ; a return in the buffer on bootup, so wipe the keyboard buffer first.
  1466                                  ;
  1467 0000069D B401                    clear_buffer:	mov ah,1			; Check for pending char
  1468 0000069F CD16                    		int 16h
  1469 000006A1 7406                    		jz get_char_time
  1470 000006A3 31C0                    		xor ax,ax			; Get char
  1471 000006A5 CD16                    		int 16h
  1472 000006A7 EBF4                    		jmp short clear_buffer
  1473 000006A9 8B0E[2819]              get_char_time:	mov cx,[KbdTimeOut]
  1474 000006AD 21C9                    		and cx,cx
  1475 000006AF 7419                    		jz get_char			; Timeout == 0 -> no timeout
  1476 000006B1 41                      		inc cx				; The first loop will happen
  1477                                  						; immediately as we don't
  1478                                  						; know the appropriate DX value
  1479 000006B2 51                      time_loop:	push cx
  1480 000006B3 52                      tick_loop:	push dx
  1481 000006B4 E8100B                  		call pollchar
  1482 000006B7 750F                    		jnz get_char_pop
  1483 000006B9 31C0                    		xor ax,ax
  1484 000006BB CD1A                    		int 1Ah				; Get time "of day"
  1485 000006BD 58                      		pop ax
  1486 000006BE 39C2                    		cmp dx,ax			; Has the timer advanced?
  1487 000006C0 74F1                    		je tick_loop
  1488 000006C2 59                      		pop cx
  1489 000006C3 E2ED                    		loop time_loop			; If so, decrement counter
  1490 000006C5 E9C100                  		jmp command_done		; Timeout!
  1491                                  
  1492 000006C8 6658                    get_char_pop:	pop eax				; Clear stack
  1493 000006CA E8110B                  get_char:	call getchar
  1494 000006CD 20C0                    		and al,al
  1495 000006CF 7462                    		jz func_key
  1496                                  
  1497 000006D1 3C7F                    got_ascii:	cmp al,7Fh			; <DEL> == <BS>
  1498 000006D3 743F                    		je backspace
  1499 000006D5 3C20                    		cmp al,' '			; ASCII?
  1500 000006D7 722A                    		jb not_ascii
  1501 000006D9 7706                    		ja enter_char
  1502 000006DB 81FF[5019]              		cmp di,command_line		; Space must not be first
  1503 000006DF 74E9                    		je get_char
  1504 000006E1 F606276501              enter_char:	test byte [FuncFlag],1
  1505 000006E6 740F                    		jz .not_ctrl_f
  1506 000006E8 C606276500              		mov byte [FuncFlag],0
  1507 000006ED 3C30                    		cmp al,'0'
  1508 000006EF 7206                    		jb .not_ctrl_f
  1509 000006F1 7437                    		je ctrl_f_0
  1510 000006F3 3C39                    		cmp al,'9'
  1511 000006F5 7635                    		jbe ctrl_f
  1512 000006F7 81FF[4F1A]              .not_ctrl_f:	cmp di,max_cmd_len+command_line ; Check there's space
  1513 000006FB 73CD                    		jnb get_char
  1514 000006FD AA                      		stosb				; Save it
  1515 000006FE E8AC0A                  		call writechr			; Echo to screen
  1516 00000701 EBC7                    get_char_2:	jmp short get_char
  1517 00000703 C606276500              not_ascii:	mov byte [FuncFlag],0
  1518 00000708 3C0D                    		cmp al,0Dh			; Enter
  1519 0000070A 747D                    		je command_done
  1520 0000070C 3C06                    		cmp al,06h			; <Ctrl-F>
  1521 0000070E 7413                    		je set_func_flag
  1522 00000710 3C08                    		cmp al,08h			; Backspace
  1523 00000712 75B6                    		jne get_char
  1524 00000714 81FF[5019]              backspace:	cmp di,command_line		; Make sure there is anything
  1525 00000718 74B0                    		je get_char			; to erase
  1526 0000071A 4F                      		dec di				; Unstore one character
  1527 0000071B BE[F914]                		mov si,wipe_char		; and erase it from the screen
  1528 0000071E E8990A                  		call cwritestr
  1529 00000721 EBDE                    		jmp short get_char_2
  1530                                  
  1531                                  set_func_flag:
  1532 00000723 C606276501              		mov byte [FuncFlag],1
  1533 00000728 EBD7                    		jmp short get_char_2
  1534                                  
  1535 0000072A 040A                    ctrl_f_0:	add al,10			; <Ctrl-F>0 == F10
  1536 0000072C 57                      ctrl_f:		push di
  1537 0000072D 2C31                    		sub al,'1'
  1538 0000072F 30E4                    		xor ah,ah
  1539 00000731 EB0E                    		jmp short show_help
  1540                                  
  1541                                  func_key:
  1542 00000733 57                      		push di
  1543 00000734 80FC44                  		cmp ah,68			; F10
  1544 00000737 77C8                    		ja get_char_2
  1545 00000739 80EC3B                  		sub ah,59			; F1
  1546 0000073C 72C3                    		jb get_char_2
  1547 0000073E C1E808                  		shr ax,8
  1548                                  show_help:	; AX = func key # (0 = F1, 9 = F10)
  1549 00000741 88C1                    		mov cl,al
  1550 00000743 C1E004                  		shl ax,4			; Convert to x16
  1551 00000746 BB0100                  		mov bx,1
  1552 00000749 D3E3                    		shl bx,cl
  1553 0000074B 231E[2A19]              		and bx,[FKeyMap]
  1554 0000074F 74B0                    		jz get_char_2			; Undefined F-key
  1555 00000751 89C7                    		mov di,ax
  1556 00000753 81C70064                		add di,FKeyName
  1557 00000757 E82308                  		call searchdir
  1558 0000075A 7405                    		jz fk_nofile
  1559 0000075C E81A09                  		call get_msg_file
  1560 0000075F EB06                    		jmp short fk_wrcmd
  1561                                  fk_nofile:
  1562 00000761 BE[CD18]                		mov si,crlf_msg
  1563 00000764 E8530A                  		call cwritestr
  1564                                  fk_wrcmd:
  1565 00000767 BE[F214]                		mov si,boot_prompt
  1566 0000076A E84D0A                  		call cwritestr
  1567 0000076D 5F                      		pop di				; Command line write pointer
  1568 0000076E 57                      		push di
  1569 0000076F C60500                  		mov byte [di],0			; Null-terminate command line
  1570 00000772 BE[5019]                		mov si,command_line
  1571 00000775 E8420A                  		call cwritestr			; Write command line so far
  1572 00000778 5F                      		pop di
  1573 00000779 EB86                    		jmp short get_char_2
  1574                                  auto_boot:
  1575 0000077B BE[511A]                		mov si,default_cmd
  1576 0000077E BF[5019]                		mov di,command_line
  1577 00000781 B94000                  		mov cx,(max_cmd_len+4) >> 2
  1578 00000784 F366A5                  		rep movsd
  1579 00000787 EB0F                    		jmp short load_kernel
  1580                                  command_done:
  1581 00000789 BE[CD18]                		mov si,crlf_msg
  1582 0000078C E82B0A                  		call cwritestr
  1583 0000078F 81FF[5019]              		cmp di,command_line		; Did we just hit return?
  1584 00000793 74E6                    		je auto_boot
  1585 00000795 30C0                    		xor al,al			; Store a final null
  1586 00000797 AA                      		stosb
  1587                                  
  1588                                  load_kernel:					; Load the kernel now
  1589                                  ;
  1590                                  ; First we need to mangle the kernel name the way DOS would...
  1591                                  ;
  1592 00000798 BE[5019]                		mov si,command_line
  1593 0000079B BFD064                                  mov di,KernelName
  1594 0000079E 56                                      push si
  1595 0000079F 57                                      push di
  1596 000007A0 E8590C                  		call mangle_name
  1597 000007A3 5F                      		pop di
  1598 000007A4 5E                                      pop si
  1599                                  ;
  1600                                  ; Fast-forward to first option (we start over from the beginning, since
  1601                                  ; mangle_name doesn't necessarily return a consistent ending state.)
  1602                                  ;
  1603 000007A5 AC                      clin_non_wsp:   lodsb
  1604 000007A6 3C20                                    cmp al,' '
  1605 000007A8 77FB                                    ja clin_non_wsp
  1606 000007AA 20C0                    clin_is_wsp:    and al,al
  1607 000007AC 7405                                    jz clin_opt_ptr
  1608 000007AE AC                                      lodsb
  1609 000007AF 3C20                                    cmp al,' '
  1610 000007B1 76F7                                    jbe clin_is_wsp
  1611 000007B3 4E                      clin_opt_ptr:   dec si                          ; Point to first nonblank
  1612 000007B4 89360C65                                mov [CmdOptPtr],si		; Save ptr to first option
  1613                                  ;
  1614                                  ; Now check if it is a "virtual kernel"
  1615                                  ;
  1616 000007B8 8B0E[3019]              		mov cx,[VKernelCtr]
  1617 000007BC 1E                      		push ds
  1618 000007BD 680040                  		push word vk_seg
  1619 000007C0 1F                      		pop ds
  1620 000007C1 83F900                  		cmp cx,byte 0
  1621 000007C4 7413                    		je not_vk
  1622 000007C6 31F6                    		xor si,si			; Point to first vkernel
  1623 000007C8 60                      vk_check:	pusha
  1624 000007C9 B90B00                  		mov cx,11
  1625 000007CC F3A6                    		repe cmpsb			; Is this it?
  1626 000007CE 0F847700                		je near vk_found
  1627 000007D2 61                      		popa
  1628 000007D3 81C60002                		add si,vk_size
  1629 000007D7 E2EF                    		loop vk_check
  1630 000007D9 1F                      not_vk:		pop ds
  1631                                  ;
  1632                                  ; Not a "virtual kernel" - check that's OK and construct the command line
  1633                                  ;
  1634 000007DA 833E[3419]00                            cmp word [AllowImplicit],byte 0
  1635 000007DF 745D                                    je bad_implicit
  1636 000007E1 06                                      push es
  1637 000007E2 56                                      push si
  1638 000007E3 57                                      push di
  1639 000007E4 BF0070                                  mov di,real_mode_seg
  1640 000007E7 8EC7                                    mov es,di
  1641 000007E9 BE0062                                  mov si,AppendBuf
  1642 000007EC BF0090                                  mov di,cmd_line_here
  1643 000007EF 8B0E[2619]                              mov cx,[AppendLen]
  1644 000007F3 F3A4                                    rep movsb
  1645 000007F5 893E[2C19]                              mov [CmdLinePtr],di
  1646 000007F9 5F                                      pop di
  1647 000007FA 5E                                      pop si
  1648 000007FB 07                                      pop es
  1649 000007FC BB1000                  		mov bx,exten_count << 2		; Alternates to try
  1650                                  ;
  1651                                  ; Find the kernel on disk
  1652                                  ;
  1653 000007FF C606DB6400              get_kernel:     mov byte [KernelName+11],0	; Zero-terminate filename/extension
  1654 00000804 66A1D864                		mov eax,[KernelName+8]		; Save initial extension
  1655 00000808 66A3[1219]              		mov [OrigKernelExt],eax
  1656 0000080C 53                      .search_loop:	push bx
  1657 0000080D BFD064                                  mov di,KernelName	      	; Search on disk
  1658 00000810 E86A07                                  call searchdir
  1659 00000813 5B                      		pop bx
  1660 00000814 756B                                    jnz kernel_good
  1661 00000816 668B87[1219]            		mov eax,[exten_table+bx]	; Try a different extension
  1662 0000081B 66A3D864                		mov [KernelName+8],eax
  1663 0000081F 83EB04                  		sub bx,byte 4
  1664 00000822 73E8                    		jnb .search_loop
  1665                                  bad_kernel:     
  1666 00000824 BED064                  		mov si,KernelName
  1667 00000827 BF3E65                                  mov di,KernelCName
  1668 0000082A 57                      		push di
  1669 0000082B E8290C                                  call unmangle_name              ; Get human form
  1670 0000082E BE[FD14]                		mov si,err_notfound		; Complain about missing kernel
  1671 00000831 E88609                  		call cwritestr
  1672 00000834 5E                      		pop si				; KernelCName
  1673 00000835 E88209                                  call cwritestr
  1674 00000838 BE[CD18]                                mov si,crlf_msg
  1675 0000083B E92A07                                  jmp abort_load                  ; Ask user for clue
  1676                                  ;
  1677                                  ; bad_implicit: The user entered a nonvirtual kernel name, with "implicit 0"
  1678                                  ;
  1679 0000083E BED064                  bad_implicit:   mov si,KernelName		; For the error message
  1680 00000841 BF3E65                                  mov di,KernelCName
  1681 00000844 E8100C                                  call unmangle_name
  1682 00000847 EBDB                                    jmp short bad_kernel
  1683                                  ;
  1684                                  ; vk_found: We *are* using a "virtual kernel"
  1685                                  ;
  1686 00000849 61                      vk_found:	popa
  1687 0000084A 57                      		push di
  1688 0000084B BF0060                  		mov di,VKernelBuf
  1689 0000084E B98000                  		mov cx,vk_size >> 2
  1690 00000851 F366A5                  		rep movsd
  1691 00000854 06                      		push es				; Restore old DS
  1692 00000855 1F                      		pop ds
  1693 00000856 06                      		push es
  1694 00000857 680070                  		push word real_mode_seg
  1695 0000085A 07                      		pop es
  1696 0000085B BF0090                  		mov di,cmd_line_here
  1697 0000085E BE1860                  		mov si,VKernelBuf+vk_append
  1698 00000861 8B0E1660                		mov cx,[VKernelBuf+vk_appendlen]
  1699 00000865 F3A4                    		rep movsb
  1700 00000867 893E[2C19]              		mov [CmdLinePtr],di		; Where to add rest of cmd
  1701 0000086B 07                      		pop es
  1702 0000086C 5F                                      pop di                          ; DI -> KernelName
  1703 0000086D 57                      		push di	
  1704 0000086E BE0B60                  		mov si,VKernelBuf+vk_rname
  1705 00000871 B90B00                  		mov cx,11			; We need ECX == CX later
  1706 00000874 F3A4                    		rep movsb
  1707 00000876 5F                      		pop di
  1708 00000877 31DB                    		xor bx,bx			; Try only one version
  1709 00000879 EB84                    		jmp get_kernel
  1710                                  ;
  1711                                  ; kernel_corrupt: Called if the kernel file does not seem healthy
  1712                                  ;
  1713 0000087B BE[1B15]                kernel_corrupt: mov si,err_notkernel
  1714 0000087E E9E706                                  jmp abort_load
  1715                                  ;
  1716                                  ; This is it!  We have a name (and location on the disk)... let's load
  1717                                  ; that sucker!!  First we have to decide what kind of file this is; base
  1718                                  ; that decision on the file extension.  The following extensions are
  1719                                  ; recognized:
  1720                                  ;
  1721                                  ; .COM 	- COMBOOT image
  1722                                  ; .CBT	- COMBOOT image
  1723                                  ; .BS	- Boot sector
  1724                                  ; .BSS	- Boot sector, but transfer over DOS superblock
  1725                                  ;
  1726                                  ; Anything else is assumed to be a Linux kernel.
  1727                                  ;
  1728                                  kernel_good:
  1729 00000881 60                      		pusha
  1730 00000882 BED064                  		mov si,KernelName
  1731 00000885 BF3E65                                  mov di,KernelCName
  1732 00000888 E8CC0B                                  call unmangle_name              ; Get human form
  1733 0000088B 81EF3E65                                sub di,KernelCName
  1734 0000088F 893E0E65                                mov [KernelCNameLen],di
  1735 00000893 61                      		popa
  1736                                  
  1737 00000894 668B0ED864              		mov ecx,[KernelName+8]		; Get (mangled) extension
  1738 00000899 6681F9434F4D00          		cmp ecx,'COM'
  1739 000008A0 0F84E003                		je near is_comboot_image
  1740 000008A4 6681F943425400          		cmp ecx,'CBT'
  1741 000008AB 0F84D503                		je near is_comboot_image
  1742 000008AF 6681F942532000          		cmp ecx,'BS '
  1743 000008B6 0F847B04                		je near is_bootsector
  1744 000008BA 6681F942535300          		cmp ecx,'BSS'
  1745 000008C1 0F847404                		je near is_bss_sector
  1746                                  		; Otherwise Linux kernel
  1747                                  ;
  1748                                  ; A Linux kernel consists of three parts: boot sector, setup code, and
  1749                                  ; kernel code.	The boot sector is never executed when using an external
  1750                                  ; booting utility, but it contains some status bytes that are necessary.
  1751                                  ; The boot sector and setup code together form exactly 5 sectors that
  1752                                  ; should be loaded at 9000:0.  The subsequent code should be loaded
  1753                                  ; at 1000:0.  For simplicity, we load the whole thing at 0F60:0, and
  1754                                  ; copy the latter stuff afterwards.
  1755                                  ;
  1756                                  ; NOTE: In the previous code I have avoided making any assumptions regarding
  1757                                  ; the size of a sector, in case this concept ever gets extended to other
  1758                                  ; media like CD-ROM (not that a CD-ROM would be bloody likely to use a FAT
  1759                                  ; filesystem, of course).  However, a "sector" when it comes to Linux booting
  1760                                  ; stuff means 512 bytes *no matter what*, so here I am using that piece
  1761                                  ; of knowledge.
  1762                                  ;
  1763                                  ; First check that our kernel is at least 64K and less than 8M (if it is
  1764                                  ; more than 8M, we need to change the logic for loading it anyway...)
  1765                                  ;
  1766                                  is_linux_kernel:
  1767 000008C5 81FA8000                                cmp dx,80h			; 8 megs
  1768 000008C9 77B0                    		ja kernel_corrupt
  1769 000008CB 21D2                    		and dx,dx
  1770 000008CD 74AC                    		jz kernel_corrupt
  1771 000008CF 50                      kernel_sane:	push ax
  1772 000008D0 52                      		push dx
  1773 000008D1 56                      		push si
  1774 000008D2 BE[B818]                		mov si,loading_msg
  1775 000008D5 E8E208                                  call cwritestr
  1776                                  ;
  1777                                  ; Now start transferring the kernel
  1778                                  ;
  1779 000008D8 680070                  		push word real_mode_seg
  1780 000008DB 07                      		pop es
  1781                                  
  1782 000008DC 50                      		push ax
  1783 000008DD 52                      		push dx
  1784 000008DE F736F264                		div word [ClustSize]		; # of clusters total
  1785 000008E2 21D2                    		and dx,dx			; Round up
  1786 000008E4 0F95C2                  		setnz dl
  1787 000008E7 0FB6D2                  		movzx dx,dl
  1788 000008EA 01D0                    		add ax,dx
  1789 000008EC A30065                                  mov [KernelClust],ax
  1790 000008EF 5A                      		pop dx
  1791 000008F0 58                      		pop ax
  1792 000008F1 A3CC64                  		mov [KernelSize],ax
  1793 000008F4 8916CE64                		mov [KernelSize+2],dx
  1794                                  ;
  1795                                  ; Now, if we transfer these straight, we'll hit 64K boundaries.	 Hence we
  1796                                  ; have to see if we're loading more than 64K, and if so, load it step by
  1797                                  ; step.
  1798                                  ;
  1799 000008F8 BA0100                  		mov dx,1			; 10000h
  1800 000008FB 31C0                    		xor ax,ax
  1801 000008FD F736F264                		div word [ClustSize]
  1802 00000901 A30465                  		mov [ClustPerMoby],ax		; Clusters/64K
  1803                                  ;
  1804                                  ; Start by loading the bootsector/setup code, to see if we need to
  1805                                  ; do something funky.  It should fit in the first 32K (loading 64K won't
  1806                                  ; work since we might have funny stuff up near the end of memory).
  1807                                  ; If we have larger than 32K clusters, yes, we're hosed.
  1808                                  ;
  1809 00000904 E84D06                  		call abort_check		; Check for abort key
  1810 00000907 8B0E0465                		mov cx,[ClustPerMoby]
  1811 0000090B D1E9                    		shr cx,1			; Half a moby
  1812 0000090D 290E0065                		sub [KernelClust],cx
  1813 00000911 31DB                    		xor bx,bx
  1814 00000913 5E                                      pop si                          ; Cluster pointer on stack
  1815 00000914 E80FFA                  		call getfssec
  1816 00000917 0F8260FF                		jc near kernel_corrupt		; Failure in first 32K
  1817 0000091B 26813EFE0155AA                          cmp word [es:bs_bootsign],0AA55h
  1818 00000922 0F8555FF                		jne near kernel_corrupt		; Boot sec signature missing
  1819                                  ;
  1820                                  ; Get the BIOS' idea of what the size of high memory is
  1821                                  ;
  1822 00000926 56                      		push si				; Save our cluster pointer!
  1823                                  
  1824 00000927 B801E8                  		mov ax,0e801h			; Query high memory (semi-recent)
  1825 0000092A CD15                    		int 15h
  1826 0000092C 7215                    		jc no_e801
  1827 0000092E 3D003C                  		cmp ax,3c00h
  1828 00000931 7710                    		ja no_e801			; > 3C00h something's wrong with this call
  1829 00000933 721A                    		jb e801_hole			; If memory hole we can only use low part
  1830                                  
  1831 00000935 89D8                    		mov ax,bx
  1832 00000937 66C1E010                		shl eax,16			; 64K chunks
  1833 0000093B 660500000001            		add eax,(16 << 20)		; Add first 16M
  1834 00000941 EB1C                    		jmp short got_highmem				
  1835                                  
  1836                                  no_e801:
  1837 00000943 B488                    		mov ah,88h			; Query high memory (oldest)
  1838 00000945 CD15                    		int 15h
  1839 00000947 3D0038                  		cmp ax,14*1024			; Don't trust memory >15M
  1840 0000094A 7603                    		jna e801_hole
  1841 0000094C B80038                  		mov ax,14*1024
  1842                                  e801_hole:
  1843 0000094F 6625FFFF0000            		and eax,0ffffh
  1844 00000955 66C1E00A                		shl eax,10			; Convert from kilobytes
  1845 00000959 660500001000            		add eax,(1 << 20)		; First megabyte
  1846                                  got_highmem:
  1847 0000095F 66A3C864                		mov [HighMemSize],eax
  1848                                  ;
  1849                                  ; Construct the command line (append options have already been copied)
  1850                                  ;
  1851 00000963 8B3E[2C19]              		mov di,[CmdLinePtr]
  1852 00000967 BE[4319]                                mov si,boot_image        	; BOOT_IMAGE=
  1853 0000096A B90B00                                  mov cx,boot_image_len
  1854 0000096D F3A4                                    rep movsb
  1855 0000096F BE3E65                                  mov si,KernelCName       	; Unmangled kernel name
  1856 00000972 8B0E0E65                                mov cx,[KernelCNameLen]
  1857 00000976 F3A4                                    rep movsb
  1858 00000978 B020                                    mov al,' '                      ; Space
  1859 0000097A AA                                      stosb
  1860 0000097B 8B360C65                                mov si,[CmdOptPtr]              ; Options from user input
  1861 0000097F B98100                  		mov cx,(kern_cmd_len+3) >> 2
  1862 00000982 F366A5                  		rep movsd
  1863                                  ;
  1864                                  %ifdef debug
  1865                                                  push ds                         ; DEBUG DEBUG DEBUG
  1866                                                  push es
  1867                                                  pop ds
  1868                                                  mov si,offset cmd_line_here
  1869                                                  call cwritestr
  1870                                                  pop ds
  1871                                                  mov si,offset crlf_msg
  1872                                                  call cwritestr
  1873                                  %endif
  1874                                  ;
  1875                                  ; Scan through the command line for anything that looks like we might be
  1876                                  ; interested in.  The original version of this code automatically assumed
  1877                                  ; the first option was BOOT_IMAGE=, but that is no longer certain.
  1878                                  ;
  1879 00000985 BE0090                  		mov si,cmd_line_here
  1880 00000988 C606[2E19]00                            mov byte [initrd_flag],0
  1881 0000098D 06                                      push es				; Set DS <- real_mode_seg
  1882 0000098E 1F                                      pop ds
  1883 0000098F AC                      get_next_opt:   lodsb
  1884 00000990 20C0                    		and al,al
  1885 00000992 0F848A00                		jz near cmdline_end
  1886 00000996 3C20                    		cmp al,' '
  1887 00000998 76F5                    		jbe get_next_opt
  1888 0000099A 4E                      		dec si
  1889 0000099B 668B04                                  mov eax,[si]
  1890 0000099E 663D7667613D                            cmp eax,'vga='
  1891 000009A4 7432                    		je is_vga_cmd
  1892 000009A6 663D6D656D3D                            cmp eax,'mem='
  1893 000009AC 7462                    		je is_mem_cmd
  1894 000009AE 06                                      push es                         ; Save ES -> real_mode_seg
  1895 000009AF 16                                      push ss
  1896 000009B0 07                                      pop es                          ; Set ES <- normal DS
  1897 000009B1 BF[DE18]                                mov di,initrd_cmd
  1898 000009B4 B90700                  		mov cx,initrd_cmd_len
  1899 000009B7 F3A6                    		repe cmpsb
  1900 000009B9 7514                                    jne not_initrd
  1901 000009BB BF3365                  		mov di,InitRD
  1902 000009BE 56                                      push si                         ; mangle_dir mangles si
  1903 000009BF E83A0A                                  call mangle_name                ; Mangle ramdisk name
  1904 000009C2 5E                                      pop si
  1905 000009C3 26803E336520            		cmp byte [es:InitRD],' '	; Null filename?
  1906 000009C9 260F9706[2E19]                          seta byte [es:initrd_flag]	; Set flag if not
  1907 000009CF 07                      not_initrd:	pop es                          ; Restore ES -> real_mode_seg
  1908 000009D0 AC                      skip_this_opt:  lodsb                           ; Load from command line
  1909 000009D1 3C20                                    cmp al,' '
  1910 000009D3 77FB                                    ja skip_this_opt
  1911 000009D5 4E                                      dec si
  1912 000009D6 EBB7                                    jmp short get_next_opt
  1913                                  is_vga_cmd:
  1914 000009D8 83C604                                  add si,byte 4
  1915 000009DB 668B04                                  mov eax,[si]
  1916 000009DE BBFFFF                                  mov bx,-1
  1917 000009E1 663D6E6F726D                            cmp eax, 'norm'                 ; vga=normal
  1918 000009E7 7421                                    je vc0
  1919 000009E9 6625FFFFFF00                            and eax,0ffffffh		; 3 bytes
  1920 000009EF BBFEFF                                  mov bx,-2
  1921 000009F2 663D65787400                            cmp eax, 'ext'                  ; vga=ext
  1922 000009F8 7410                                    je vc0
  1923 000009FA BBFDFF                                  mov bx,-3
  1924 000009FD 663D61736B00                            cmp eax, 'ask'                  ; vga=ask
  1925 00000A03 7405                                    je vc0
  1926 00000A05 E82109                                  call parseint                   ; vga=<number>
  1927 00000A08 72C6                    		jc skip_this_opt		; Not an integer
  1928 00000A0A 891EFA01                vc0:		mov [bs_vidmode],bx		; Set video mode
  1929 00000A0E EBC0                    		jmp short skip_this_opt
  1930                                  is_mem_cmd:
  1931 00000A10 83C604                                  add si,byte 4
  1932 00000A13 E81309                                  call parseint
  1933 00000A16 72B8                    		jc skip_this_opt		; Not an integer
  1934 00000A18 2E66891EC864            		mov [cs:HighMemSize],ebx
  1935 00000A1E EBB0                    		jmp short skip_this_opt
  1936                                  cmdline_end:
  1937 00000A20 0E                                      push cs                         ; Restore standard DS
  1938 00000A21 1F                                      pop ds
  1939 00000A22 81EE0090                		sub si,cmd_line_here
  1940 00000A26 89361A65                		mov [CmdLineLen],si		; Length including final null
  1941                                  ;
  1942                                  ; Now check if we have a large kernel, which needs to be loaded high
  1943                                  ;
  1944 00000A2A 2666813E0202486472-     		cmp dword [es:su_header],HEADER_ID	; New setup code ID
  1944 00000A33 53                 
  1945 00000A34 0F853102                		jne near old_kernel		; Old kernel, load low
  1946 00000A38 26813E06020002          		cmp word [es:su_version],0200h	; Setup code version 2.0
  1947 00000A3F 0F822602                		jb near old_kernel		; Old kernel, load low
  1948 00000A43 26813E06020102                          cmp word [es:su_version],0201h	; Version 2.01+?
  1949 00000A4A 720D                                    jb new_kernel                   ; If 2.00, skip this step
  1950 00000A4C 26C7062402F48F                          mov word [es:su_heapend],linux_stack	; Set up the heap
  1951 00000A53 26800E110280                            or byte [es:su_loadflags],80h	; Let the kernel know we care
  1952                                  ;
  1953                                  ; We definitely have a new-style kernel.  Let the kernel know who we are,
  1954                                  ; and that we are clueful
  1955                                  ;
  1956                                  new_kernel:
  1957 00000A59 26C606100231            		mov byte [es:su_loader],syslinux_id	; Show some ID
  1958 00000A5F 260FB606F101            		movzx ax,byte [es:bs_setupsecs]	; Variable # of setup sectors
  1959 00000A65 A31465                  		mov [SetupSecs],ax
  1960                                  ;
  1961                                  ; Now see if we have an initial RAMdisk; if so, do requisite computation
  1962                                  ;
  1963 00000A68 F606[2E19]01                            test byte [initrd_flag],1
  1964 00000A6D 7478                                    jz nk_noinitrd
  1965 00000A6F 06                                      push es                         ; ES->real_mode_seg
  1966 00000A70 1E                                      push ds
  1967 00000A71 07                                      pop es                          ; We need ES==DS
  1968 00000A72 BE3365                                  mov si,InitRD
  1969 00000A75 BF4B65                                  mov di,InitRDCName
  1970 00000A78 E8DC09                                  call unmangle_name              ; Create human-readable name
  1971 00000A7B 81EF4B65                                sub di,InitRDCName
  1972 00000A7F 893E1065                                mov [InitRDCNameLen],di
  1973 00000A83 BF3365                                  mov di,InitRD
  1974 00000A86 E8F404                                  call searchdir                  ; Look for it in directory
  1975 00000A89 07                                      pop es
  1976 00000A8A 7443                    		jz initrd_notthere
  1977 00000A8C 8936[2E19]              		mov [initrd_ptr],si		; Save cluster pointer
  1978 00000A90 26A31C02                		mov [es:su_ramdisklen1],ax	; Ram disk length
  1979 00000A94 2689161E02              		mov [es:su_ramdisklen2],dx
  1980 00000A99 F736F264                		div word [ClustSize]
  1981 00000A9D 21D2                    		and dx,dx			; Round up
  1982 00000A9F 0F95C2                  		setnz dl
  1983 00000AA2 0FB6D2                  		movzx dx,dl
  1984 00000AA5 01D0                    		add ax,dx
  1985 00000AA7 A30265                  		mov [InitRDClust],ax		; Ramdisk clusters
  1986 00000AAA 668B16C864              		mov edx,[HighMemSize]		; End of memory
  1987 00000AAF 66B800000038            		mov eax,HIGHMEM_MAX		; Limit imposed by kernel
  1988 00000AB5 6639C2                  		cmp edx,eax
  1989 00000AB8 7603                    		jna memsize_ok
  1990 00000ABA 6689C2                  		mov edx,eax			; Adjust to fit inside limit
  1991                                  memsize_ok:
  1992 00000ABD 26662B161C02            		sub edx,[es:su_ramdisklen]	; Subtract size of ramdisk
  1993 00000AC3 31D2                                    xor dx,dx			; Round down to 64K boundary
  1994 00000AC5 668916C064                              mov [InitRDat],edx		; Load address
  1995 00000ACA E80804                  		call loadinitrd			; Load initial ramdisk
  1996 00000ACD EB18                    		jmp short initrd_end
  1997                                  
  1998                                  initrd_notthere:
  1999 00000ACF BE[5017]                                mov si,err_noinitrd
  2000 00000AD2 E8E506                                  call cwritestr
  2001 00000AD5 BE4B65                                  mov si,InitRDCName
  2002 00000AD8 E8DF06                                  call cwritestr
  2003 00000ADB BE[CD18]                                mov si,crlf_msg
  2004 00000ADE E98704                                  jmp abort_load
  2005                                  
  2006 00000AE1 BE[7117]                no_high_mem:    mov si,err_nohighmem		; Error routine
  2007 00000AE4 E98104                                  jmp abort_load
  2008                                  ;
  2009                                  ; About to load the kernel.  This is a modern kernel, so use the boot flags
  2010                                  ; we were provided.
  2011                                  ;
  2012                                  nk_noinitrd:
  2013                                  initrd_end:
  2014 00000AE7 26A01102                                mov al,[es:su_loadflags]
  2015 00000AEB A22465                  		mov [LoadFlags],al
  2016                                  ;
  2017                                  ; Load the kernel.  We always load it at 100000h even if we're supposed to
  2018                                  ; load it "low"; for a "low" load we copy it down to low memory right before
  2019                                  ; jumping to it.
  2020                                  ;
  2021                                  read_kernel:
  2022 00000AEE BE3E65                                  mov si,KernelCName		; Print kernel name part of
  2023 00000AF1 E8C606                                  call cwritestr                  ; "Loading" message
  2024 00000AF4 BE[C118]                                mov si,dotdot_msg		; Print dots
  2025 00000AF7 E8C006                                  call cwritestr
  2026                                  
  2027 00000AFA 66A1C864                                mov eax,[HighMemSize]
  2028 00000AFE 662D00001000            		sub eax,100000h			; Load address
  2029 00000B04 663B06CC64              		cmp eax,[KernelSize]
  2030 00000B09 72D6                    		jb no_high_mem			; Not enough high memory
  2031                                  ;
  2032                                  ; Move the stuff beyond the setup code to high memory at 100000h
  2033                                  ;
  2034 00000B0B 660FB7361465            		movzx esi,word [SetupSecs]	; Setup sectors
  2035 00000B11 6646                    		inc esi				; plus 1 boot sector
  2036 00000B13 66C1E609                                shl esi,9			; Convert to bytes
  2037 00000B17 66B900801000                            mov ecx,108000h			; 108000h = 1M + 32K
  2038 00000B1D 6629F1                                  sub ecx,esi			; Adjust pointer to 2nd block
  2039 00000B20 66890EC464                              mov [HiLoadAddr],ecx
  2040 00000B25 6681E900001000          		sub ecx,100000h			; Turn into a counter
  2041 00000B2C 66C1E902                		shr ecx,2			; Convert to dwords
  2042 00000B30 6681C600000700          		add esi,(real_mode_seg << 4)	; Pointer to source
  2043 00000B37 66BF00001000                            mov edi,100000h                 ; Copy to address 100000h
  2044 00000B3D E87402                                  call bcopy			; Transfer to high memory
  2045                                  
  2046 00000B40 680030                                  push word xfer_buf_seg		; Transfer buffer segment
  2047 00000B43 07                                      pop es
  2048                                  high_load_loop: 
  2049 00000B44 BE[C218]                                mov si,dot_msg			; Progress report
  2050 00000B47 E87006                                  call cwritestr
  2051 00000B4A E80704                                  call abort_check
  2052 00000B4D 8B0E0065                                mov cx,[KernelClust]
  2053 00000B51 3B0E0465                		cmp cx,[ClustPerMoby]
  2054 00000B55 7604                    		jna high_last_moby
  2055 00000B57 8B0E0465                		mov cx,[ClustPerMoby]
  2056                                  high_last_moby:
  2057 00000B5B 290E0065                		sub [KernelClust],cx
  2058 00000B5F 31DB                    		xor bx,bx			; Load at offset 0
  2059 00000B61 5E                                      pop si                          ; Restore cluster pointer
  2060 00000B62 E8C1F7                                  call getfssec
  2061 00000B65 56                                      push si                         ; Save cluster pointer
  2062 00000B66 9C                                      pushf                           ; Save EOF
  2063 00000B67 31DB                                    xor bx,bx
  2064 00000B69 66BE00000300            		mov esi,(xfer_buf_seg << 4)
  2065 00000B6F 668B3EC464                              mov edi,[HiLoadAddr]		; Destination address
  2066 00000B74 66B900400000                            mov ecx,4000h			; Cheating - transfer 64K
  2067 00000B7A E83702                                  call bcopy			; Transfer to high memory
  2068 00000B7D 66893EC464              		mov [HiLoadAddr],edi		; Point to next target area
  2069 00000B82 9D                                      popf                            ; Restore EOF
  2070 00000B83 7207                                    jc high_load_done               ; If EOF we are done
  2071 00000B85 833E006500                              cmp word [KernelClust],byte 0	; Are we done?
  2072 00000B8A 75B8                    		jne high_load_loop		; Apparently not
  2073                                  high_load_done:
  2074 00000B8C 5E                      		pop si				; No longer needed
  2075 00000B8D B80070                                  mov ax,real_mode_seg		; Set to real mode seg
  2076 00000B90 8EC0                                    mov es,ax
  2077                                  
  2078 00000B92 BE[C218]                                mov si,dot_msg
  2079 00000B95 E82206                                  call cwritestr
  2080                                  ;
  2081                                  ; Abandon hope, ye that enter here!  We do no longer permit aborts.
  2082                                  ;
  2083 00000B98 E8B903                                  call abort_check        	; Last chance!!
  2084                                  
  2085 00000B9B BE[AE18]                		mov si,ready_msg
  2086 00000B9E E81906                  		call cwritestr
  2087                                  ;
  2088                                  ; Now, if we were supposed to load "low", copy the kernel down to 10000h
  2089                                  ; and the real mode stuff to 90000h.  We assume that all bzImage kernels are
  2090                                  ; capable of starting their setup from a different address.
  2091                                  ;
  2092 00000BA1 BB0070                  		mov bx,real_mode_seg		; Real mode segment
  2093 00000BA4 8EE3                    		mov fs,bx			; FS -> real_mode_seg
  2094                                  ;
  2095                                  ; Copy command line.  Unfortunately, the kernel boot protocol requires
  2096                                  ; the command line to exist in the 9xxxxh range even if the rest of the
  2097                                  ; setup doesn't.
  2098                                  ;
  2099 00000BA6 FA                      		cli				; In case of hooked interrupts
  2100 00000BA7 F606246501              		test byte [LoadFlags],LOAD_HIGH
  2101 00000BAC 7415                    		jz need_high_cmdline
  2102 00000BAE 64813E06020202          		cmp word [fs:su_version],0202h	; Support new cmdline protocol?
  2103 00000BB5 720C                    		jb need_high_cmdline
  2104                                  		; New cmdline protocol
  2105                                  		; Store 32-bit (flat) pointer to command line
  2106 00000BB7 6466C7062802009007-     		mov dword [fs:su_cmd_line_ptr],(real_mode_seg << 4) + cmd_line_here
  2106 00000BC0 00                 
  2107 00000BC1 EB7A                    		jmp short in_proper_place
  2108                                  
  2109                                  need_high_cmdline:
  2110                                  ;
  2111                                  ; Copy command line up to 90000h
  2112                                  ;
  2113 00000BC3 B80090                  		mov ax,9000h
  2114 00000BC6 8EC0                    		mov es,ax
  2115 00000BC8 BE0090                  		mov si,cmd_line_here
  2116 00000BCB 89F7                    		mov di,si
  2117 00000BCD 64C70620003FA3          		mov [fs:kern_cmd_magic],word CMD_MAGIC ; Store magic
  2118 00000BD4 64893E2200              		mov [fs:kern_cmd_offset],di	; Store pointer
  2119                                  
  2120 00000BD9 8B0E1A65                		mov cx,[CmdLineLen]
  2121 00000BDD 83C103                  		add cx,byte 3
  2122 00000BE0 C1E902                  		shr cx,2			; Convert to dwords
  2123 00000BE3 F36466A5                		fs rep movsd
  2124                                  
  2125 00000BE7 F606246501              		test byte [LoadFlags],LOAD_HIGH
  2126                                  		; Note bx -> real_mode_seg still
  2127 00000BEC 754F                    		jnz in_proper_place		; If high load, we're done
  2128                                  
  2129                                  ;
  2130                                  ; Loading low; we can't assume it's safe to run in place.
  2131                                  ;
  2132                                  ; Copy real_mode stuff up to 90000h
  2133                                  ;
  2134 00000BEE B80070                  		mov ax,real_mode_seg
  2135 00000BF1 8EE0                    		mov fs,ax
  2136 00000BF3 B80090                  		mov ax,9000h
  2137 00000BF6 8EC0                    		mov es,ax
  2138 00000BF8 8B0E1465                		mov cx,[SetupSecs]
  2139 00000BFC 41                      		inc cx				; Setup + boot sector
  2140 00000BFD C1E107                  		shl cx,7			; Sectors -> dwords
  2141 00000C00 31F6                    		xor si,si
  2142 00000C02 31FF                    		xor di,di
  2143 00000C04 F36466A5                		fs rep movsd			; Copy setup + boot sector
  2144                                  ;
  2145                                  ; Some kernels in the 1.2 ballpark but pre-bzImage have more than 4
  2146                                  ; setup sectors, but the boot protocol had not yet been defined.  They
  2147                                  ; rely on a signature to figure out if they need to copy stuff from
  2148                                  ; the "protected mode" kernel area.  Unfortunately, we used that area
  2149                                  ; as a transfer buffer, so it's going to find the signature there.
  2150                                  ; Hence, zero the low 32K beyond the setup area.
  2151                                  ;
  2152 00000C08 8B3E1465                		mov di,[SetupSecs]
  2153 00000C0C 47                      		inc di				; Setup + boot sector
  2154 00000C0D B94000                  		mov cx,32768/512		; Sectors/32K
  2155 00000C10 29F9                    		sub cx,di			; Remaining sectors
  2156 00000C12 C1E709                  		shl di,9			; Sectors -> bytes
  2157 00000C15 C1E107                  		shl cx,7			; Sectors -> dwords
  2158 00000C18 6631C0                  		xor eax,eax
  2159 00000C1B F366AB                  		rep stosd			; Clear region
  2160                                  ;
  2161 00000C1E 668B0ECC64              		mov ecx,[KernelSize]
  2162 00000C23 6683C103                		add ecx,3			; Round upwards
  2163 00000C27 66C1E902                		shr ecx,2			; Bytes -> dwords
  2164 00000C2B 66BE00001000            		mov esi,100000h
  2165 00000C31 66BF00000100            		mov edi,10000h
  2166 00000C37 E87A01                  		call bcopy
  2167                                  
  2168 00000C3A BB0090                  		mov bx,9000h			; Real mode segment
  2169                                  
  2170                                  ;
  2171                                  ; Now everything is where it needs to be...
  2172                                  ;
  2173                                  in_proper_place:
  2174 00000C3D 8EC3                    		mov es,bx			; Real mode segment
  2175                                  ;
  2176                                  ; If the default root device is set to FLOPPY (0000h), change to
  2177                                  ; /dev/fd0 (0200h)
  2178                                  ;
  2179 00000C3F 26833EFC0100            		cmp word [es:bs_rootdev],byte 0
  2180 00000C45 7507                    		jne root_not_floppy
  2181 00000C47 26C706FC010002          		mov word [es:bs_rootdev],0200h
  2182                                  root_not_floppy:
  2183                                  ;
  2184                                  ; Copy the disk table to high memory, then re-initialize the floppy
  2185                                  ; controller
  2186                                  ;
  2187                                  ; This needs to be moved before the copy
  2188                                  ;
  2189                                  %if 0
  2190                                  		push ds
  2191                                  		push bx
  2192                                  		lds si,[fdctab]
  2193                                  		mov di,linux_fdctab
  2194                                  		mov cx,3			; 12 bytes
  2195                                  		push di
  2196                                  		rep movsd
  2197                                  		pop di
  2198                                  		mov [fdctab1],di		; Save new floppy tab pos
  2199                                  		mov [fdctab2],es
  2200                                  		xor ax,ax
  2201                                  		xor dx,dx
  2202                                  		int 13h
  2203                                  		pop bx
  2204                                  		pop ds
  2205                                  %endif
  2206                                  ;
  2207                                  ; Linux wants the floppy motor shut off before starting the kernel,
  2208                                  ; at least bootsect.S seems to imply so
  2209                                  ;
  2210                                  kill_motor:
  2211 00000C4E BAF203                  		mov dx,03F2h
  2212 00000C51 30C0                    		xor al,al
  2213 00000C53 E8B301                  		call slow_out
  2214                                  ;
  2215                                  ; If we're debugging, wait for a keypress so we can read any debug messages
  2216                                  ;
  2217                                  %ifdef debug
  2218                                                  xor ax,ax
  2219                                                  int 16h
  2220                                  %endif
  2221                                  ;
  2222                                  ; Set up segment registers and the Linux real-mode stack
  2223                                  ; Note: bx == the real mode segment
  2224                                  ;
  2225 00000C56 FA                      		cli
  2226                                  		; es is already == real mode segment
  2227 00000C57 8EDB                    		mov ds,bx
  2228 00000C59 8EE3                    		mov fs,bx
  2229 00000C5B 8EEB                    		mov gs,bx
  2230 00000C5D 8ED3                    		mov ss,bx
  2231 00000C5F BCF48F                  		mov sp,linux_stack
  2232                                  ;
  2233                                  ; We're done... now RUN THAT KERNEL!!!!
  2234                                  ; Setup segment == real mode segment + 020h; we need to jump to offset
  2235                                  ; zero in the real mode segment.
  2236                                  ;
  2237 00000C62 83C320                  		add bx,020h
  2238 00000C65 53                      		push bx
  2239 00000C66 6A00                    		push word 0h
  2240 00000C68 CB                      		retf
  2241                                  
  2242                                  ;
  2243                                  ; Load an older kernel.  Older kernels always have 4 setup sectors, can't have
  2244                                  ; initrd, and are always loaded low.
  2245                                  ;
  2246                                  old_kernel:
  2247 00000C69 F606[2E19]01                            test byte [initrd_flag],1	; Old kernel can't have initrd
  2248 00000C6E 7406                                    jz load_old_kernel
  2249 00000C70 BE[BC17]                                mov si,err_oldkernel
  2250 00000C73 E9F202                                  jmp abort_load
  2251                                  load_old_kernel:
  2252 00000C76 C70614650400            		mov word [SetupSecs],4		; Always 4 setup sectors
  2253 00000C7C C606246500              		mov byte [LoadFlags],0		; Always low
  2254 00000C81 E96AFE                  		jmp read_kernel
  2255                                  
  2256                                  ;
  2257                                  ; Load a COMBOOT image.  A COMBOOT image is basically a DOS .COM file,
  2258                                  ; except that it may, of course, not contain any DOS system calls.  We
  2259                                  ; do, however, allow the execution of INT 20h to return to SYSLINUX.
  2260                                  ;
  2261                                  is_comboot_image:
  2262 00000C84 21D2                    		and dx,dx
  2263 00000C86 7574                    		jnz comboot_too_large
  2264 00000C88 3D00FF                  		cmp ax,0ff00h		; Max size in bytes
  2265 00000C8B 736F                    		jae comboot_too_large
  2266                                  
  2267                                  		;
  2268                                  		; Set up the DOS vectors in the IVT (INT 20h-3fh)
  2269                                  		;
  2270 00000C8D 66C7068000-             		mov dword [4*0x20],comboot_return	; INT 20h vector
  2270 00000C92 [050D0000]         
  2271 00000C96 66B8[170D0000]          		mov eax,comboot_bogus
  2272 00000C9C BF8400                  		mov di,4*0x21
  2273 00000C9F B91F00                  		mov cx,31		; All remaining DOS vectors
  2274 00000CA2 F366AB                  		rep stosd
  2275                                  	
  2276 00000CA5 B90020                  		mov cx,comboot_seg
  2277 00000CA8 8EC1                    		mov es,cx
  2278                                  
  2279 00000CAA BB0001                  		mov bx,100h		; Load at <seg>:0100h
  2280                                  
  2281 00000CAD 8B0E0465                		mov cx,[ClustPerMoby]	; Absolute maximum # of clusters
  2282 00000CB1 E872F6                  		call getfssec
  2283                                  
  2284 00000CB4 31FF                    		xor di,di
  2285 00000CB6 B94000                  		mov cx,64		; 256 bytes (size of PSP)
  2286 00000CB9 6631C0                  		xor eax,eax		; Clear PSP
  2287 00000CBC F366AB                  		rep stosd
  2288                                  
  2289 00000CBF 26C7060000CD20          		mov word [es:0], 020CDh	; INT 20h instruction
  2290                                  		; First non-free paragraph
  2291 00000CC6 26C70602000030          		mov word [es:02h], comboot_seg+1000h
  2292                                  
  2293                                  		; Copy the command line from high memory
  2294 00000CCD B97D00                  		mov cx,125		; Max cmdline len (minus space and CR)
  2295 00000CD0 8B360C65                		mov si,[CmdOptPtr]
  2296 00000CD4 BF8100                  		mov di,081h		; Offset in PSP for command line
  2297 00000CD7 B020                    		mov al,' '		; DOS command lines begin with a space
  2298 00000CD9 AA                      		stosb
  2299                                  
  2300 00000CDA AC                      comboot_cmd_cp:	lodsb
  2301 00000CDB 20C0                    		and al,al
  2302 00000CDD 7403                    		jz comboot_end_cmd
  2303 00000CDF AA                      		stosb
  2304 00000CE0 E2F8                    		loop comboot_cmd_cp
  2305 00000CE2 B00D                    comboot_end_cmd: mov al,0Dh		; CR after last character
  2306 00000CE4 AA                      		stosb
  2307 00000CE5 B07E                    		mov al,126		; Include space but not CR
  2308 00000CE7 28C8                    		sub al,cl
  2309 00000CE9 26A28000                		mov [es:80h], al	; Store command line length
  2310                                  
  2311 00000CED 8CC0                    		mov ax,es
  2312 00000CEF 8ED8                    		mov ds,ax
  2313 00000CF1 8ED0                    		mov ss,ax
  2314 00000CF3 31E4                    		xor sp,sp
  2315 00000CF5 6A00                    		push word 0		; Return to address 0 -> exit
  2316                                  
  2317 00000CF7 EA00010020              		jmp comboot_seg:100h	; Run it
  2318                                  
  2319                                  ; Looks like a COMBOOT image but too large
  2320                                  comboot_too_large:
  2321 00000CFC BE[0C18]                		mov si,err_comlarge
  2322 00000CFF E8B804                  		call cwritestr
  2323 00000D02 E98AF9                  cb_enter:	jmp enter_command
  2324                                  
  2325                                  ; Proper return vector
  2326 00000D05 FA                      comboot_return:	cli			; Don't trust anyone
  2327 00000D06 31C0                    		xor ax,ax
  2328 00000D08 8ED0                    		mov ss,ax
  2329 00000D0A 368B261665              		mov sp,[ss:SavedSP]
  2330 00000D0F 8ED8                    		mov ds,ax
  2331 00000D11 8EC0                    		mov es,ax
  2332 00000D13 FB                      		sti
  2333 00000D14 FC                      		cld
  2334 00000D15 EBEB                    		jmp short cb_enter
  2335                                  
  2336                                  ; Attempted to execute DOS system call
  2337 00000D17 FA                      comboot_bogus:	cli			; Don't trust anyone
  2338 00000D18 31C0                    		xor ax,ax
  2339 00000D1A 8ED0                    		mov ss,ax
  2340 00000D1C 368B261665              		mov sp,[ss:SavedSP]
  2341 00000D21 8ED8                    		mov ds,ax
  2342 00000D23 8EC0                    		mov es,ax
  2343 00000D25 FB                      		sti
  2344 00000D26 FC                      		cld
  2345 00000D27 BE3E65                  		mov si,KernelCName
  2346 00000D2A E88D04                  		call cwritestr
  2347 00000D2D BE[EE17]                		mov si,err_notdos
  2348 00000D30 E88704                  		call cwritestr
  2349 00000D33 EBCD                    		jmp short cb_enter
  2350                                  
  2351                                  ;
  2352                                  ; Load a boot sector
  2353                                  ;
  2354                                  is_bootsector:
  2355                                  		; Transfer zero bytes
  2356 00000D35 6A00                    		push word 0
  2357 00000D37 EB02                    		jmp short load_bootsec
  2358                                  is_bss_sector:
  2359                                  		; Transfer the superblock
  2360 00000D39 6A33                    		push word superblock_len
  2361                                  load_bootsec:
  2362 00000D3B 21D2                    		and dx,dx
  2363 00000D3D 754C                    		jnz bad_bootsec
  2364 00000D3F 8B1E[0B00]              		mov bx,[bsBytesPerSec]
  2365 00000D43 39D8                    		cmp ax,bx
  2366 00000D45 7544                    		jne bad_bootsec
  2367                                  
  2368                                  		; Make sure we don't test this uninitialized
  2369 00000D47 8997FE0F                		mov [bx+trackbuf-2],dx	; Note DX == 0
  2370                                  
  2371 00000D4B BB0010                  		mov bx,trackbuf
  2372 00000D4E B90100                  		mov cx,1		; 1 cluster >= 1 sector
  2373 00000D51 E8D2F5                  		call getfssec
  2374                                  
  2375 00000D54 8B1E[0B00]              		mov bx,[bsBytesPerSec]
  2376 00000D58 8B87FE0F                		mov ax,[bx+trackbuf-2]
  2377 00000D5C 3D55AA                  		cmp ax,0AA55h		; Boot sector signature
  2378 00000D5F 752A                    		jne bad_bootsec
  2379                                  
  2380 00000D61 BE[0B00]                		mov si,superblock
  2381 00000D64 BF0B10                  		mov di,trackbuf+(superblock-bootsec)
  2382 00000D67 59                      		pop cx			; Transfer count
  2383 00000D68 F3A4                    		rep movsb
  2384                                  ;
  2385                                  ; Okay, here we go... copy over our own boot sector and run the new one
  2386                                  ;
  2387 00000D6A FA                      		cli			; Point of no return
  2388                                  	
  2389 00000D6B 8A16[2400]              		mov dl,[bsDriveNumber]	; May not be in new bootsector!
  2390                                  
  2391 00000D6F BE0010                  		mov si,trackbuf
  2392 00000D72 BF[0000]                		mov di,bootsec
  2393 00000D75 8B0E[0B00]              		mov cx,[bsBytesPerSec]
  2394 00000D79 F3A4                    		rep movsb		; Copy the boot sector!
  2395                                  		
  2396 00000D7B BEB064                  		mov si,PartInfo
  2397 00000D7E BFEE07                  		mov di,800h-18		; Put partition info here
  2398 00000D81 57                      		push di
  2399 00000D82 B90800                  		mov cx,8		; 16 bytes
  2400 00000D85 F3A5                    		rep movsw
  2401 00000D87 5E                      		pop si			; DS:SI points to partition info
  2402                                  
  2403 00000D88 E975F2                  		jmp bootsec
  2404                                  
  2405                                  bad_bootsec:
  2406 00000D8B BE[2718]                		mov si,err_bootsec
  2407 00000D8E E82904                  		call cwritestr
  2408 00000D91 E9FBF8                  		jmp enter_command
  2409                                  
  2410                                  ;
  2411                                  ; 32-bit bcopy routine for real mode
  2412                                  ;
  2413                                  ; We enter protected mode, set up a flat 32-bit environment, run rep movsd
  2414                                  ; and then exit.  IMPORTANT: This code assumes cs == ss == 0.
  2415                                  ;
  2416                                  ; This code is probably excessively anal-retentive in its handling of
  2417                                  ; segments, but this stuff is painful enough as it is without having to rely
  2418                                  ; on everything happening "as it ought to."
  2419                                  ;
  2420                                  		align 4
  2421 00000D94 1F00                    bcopy_gdt:	dw bcopy_gdt_size-1	; Null descriptor - contains GDT
  2422 00000D96 [940D0000]              		dd bcopy_gdt		; pointer for LGDT instruction
  2423 00000D9A 0000                    		dw 0
  2424 00000D9C FFFF0000                		dd 0000ffffh		; Code segment, use16, readable,
  2425 00000DA0 009B0000                		dd 00009b00h		; present, dpl 0, cover 64K
  2426 00000DA4 FFFF0000                		dd 0000ffffh		; Data segment, use16, read/write,
  2427 00000DA8 00938F00                		dd 008f9300h		; present, dpl 0, cover all 4G
  2428 00000DAC FFFF0000                		dd 0000ffffh		; Data segment, use16, read/write,
  2429 00000DB0 00930000                		dd 00009300h		; present, dpl 0, cover 64K
  2430                                  bcopy_gdt_size:	equ $-bcopy_gdt
  2431                                  
  2432 00000DB4 6650                    bcopy:		push eax
  2433 00000DB6 9C                      		pushf			; Saves, among others, the IF flag
  2434 00000DB7 0FA8                    		push gs
  2435 00000DB9 0FA0                    		push fs
  2436 00000DBB 1E                      		push ds
  2437 00000DBC 06                      		push es
  2438                                  
  2439 00000DBD FA                      		cli
  2440 00000DBE E85200                  		call enable_a20
  2441                                  
  2442 00000DC1 660F0116[940D]          		o32 lgdt [bcopy_gdt]
  2443 00000DC7 0F20C0                  		mov eax,cr0
  2444 00000DCA 0C01                    		or al,1
  2445 00000DCC 0F22C0                  		mov cr0,eax		; Enter protected mode
  2446 00000DCF EA[D40D]0800            		jmp 08h:.in_pm
  2447                                  
  2448 00000DD4 B81000                  .in_pm:		mov ax,10h		; Data segment selector
  2449 00000DD7 8EC0                    		mov es,ax
  2450 00000DD9 8ED8                    		mov ds,ax
  2451                                  
  2452 00000DDB B018                    		mov al,18h		; "Real-mode-like" data segment
  2453 00000DDD 8ED0                    		mov ss,ax
  2454 00000DDF 8EE0                    		mov fs,ax
  2455 00000DE1 8EE8                    		mov gs,ax	
  2456                                  	
  2457 00000DE3 F36667A5                		a32 rep movsd		; Do our business
  2458                                  		
  2459 00000DE7 8EC0                    		mov es,ax		; Set to "real-mode-like"
  2460 00000DE9 8ED8                    		mov ds,ax
  2461                                  	
  2462 00000DEB 0F20C0                  		mov eax,cr0
  2463 00000DEE 24FE                    		and al,~1
  2464 00000DF0 0F22C0                  		mov cr0,eax		; Disable protected mode
  2465 00000DF3 EA[F80D]0000            		jmp 0:.in_rm
  2466                                  
  2467 00000DF8 31C0                    .in_rm:		xor ax,ax		; Back in real mode
  2468 00000DFA 8ED0                    		mov ss,ax
  2469 00000DFC 07                      		pop es
  2470 00000DFD 1F                      		pop ds
  2471 00000DFE 0FA1                    		pop fs
  2472 00000E00 0FA9                    		pop gs
  2473 00000E02 E87D00                  		call disable_a20
  2474                                  
  2475 00000E05 9D                      		popf			; Re-enables interrupts
  2476 00000E06 6658                    		pop eax
  2477 00000E08 C3                      		ret
  2478                                  
  2479                                  ;
  2480                                  ; Routines to enable and disable (yuck) A20.  These routines are gathered
  2481                                  ; from tips from a couple of sources, including the Linux kernel and
  2482                                  ; http://www.x86.org/.  The need for the delay to be as large as given here
  2483                                  ; is indicated by Donnie Barnes of RedHat, the problematic system being an
  2484                                  ; IBM ThinkPad 760EL.
  2485                                  ;
  2486                                  ; We typically toggle A20 twice for every 64K transferred.
  2487                                  ; 
  2488                                  %define	io_delay	call _io_delay
  2489                                  %define IO_DELAY_PORT	80h		; Invalid port (we hope!)
  2490                                  %define delaytime 	1024		; 4 x ISA bus cycles (@ 1.5 s)
  2491                                  
  2492 00000E09 EE                      slow_out:	out dx, al		; Fall through
  2493                                  
  2494 00000E0A E680                    _io_delay:	out IO_DELAY_PORT,al
  2495 00000E0C E680                    		out IO_DELAY_PORT,al
  2496 00000E0E E680                    		out IO_DELAY_PORT,al
  2497 00000E10 E680                    		out IO_DELAY_PORT,al
  2498 00000E12 C3                      		ret
  2499                                  
  2500                                  enable_a20:
  2501 00000E13 36C6062565FF            		mov byte [ss:A20Tries],255 ; Times to try to make this work
  2502                                  
  2503                                  .try_enable_a20:
  2504                                  ;
  2505                                  ; Flush the caches
  2506                                  ;
  2507 00000E19 E8B600                  		call try_wbinvd
  2508                                  
  2509                                  ;
  2510                                  ; Enable the "fast A20 gate"
  2511                                  ;
  2512 00000E1C 36C606266500            		mov byte [ss:A20KBCflag], 0	; Haven't used the KBC yet
  2513 00000E22 E492                    		in al, 092h
  2514 00000E24 0C02                    		or al,02h
  2515 00000E26 24FE                    		and al,~01h			; Don't accidentally reset the machine!
  2516 00000E28 E692                    		out 092h, al
  2517                                  ;
  2518                                  ; Enable the keyboard controller A20 gate
  2519                                  ;
  2520 00000E2A B201                    		mov dl, 1			; Allow early exit
  2521 00000E2C E88200                  		call empty_8042
  2522 00000E2F 7514                    		jnz .a20_wait			; A20 live, no need to use KBC
  2523                                  
  2524 00000E31 36C606266501            		mov byte [ss:A20KBCflag], 1	; We touched the KBC
  2525 00000E37 B0D1                    		mov al,0D1h			; Command write
  2526 00000E39 E664                    		out 064h, al
  2527 00000E3B E87100                  		call empty_8042_uncond
  2528                                  
  2529 00000E3E B0DF                    		mov al,0DFh		; A20 on
  2530 00000E40 E660                    		out 060h, al
  2531 00000E42 E86A00                  		call empty_8042_uncond
  2532                                  
  2533                                  		; Verify that A20 actually is enabled.  Do that by
  2534                                  		; observing a word in low memory and the same word in
  2535                                  		; the HMA until they are no longer coherent.  Note that
  2536                                  		; we don't do the same check in the disable case, because
  2537                                  		; we don't want to *require* A20 masking (SYSLINUX should
  2538                                  		; work fine without it, if the BIOS does.)
  2539 00000E45 51                      .a20_wait:	push cx
  2540 00000E46 B9FFFF                  		mov cx, 0FFFFh
  2541                                  .a20_wait_loop:
  2542 00000E49 E81400                  		call a20_test
  2543 00000E4C 7510                    		jnz .a20_done
  2544 00000E4E E2F9                    		loop .a20_wait_loop
  2545                                  ;
  2546                                  ; Oh bugger.  A20 is not responding.  Try frobbing it again; eventually give up
  2547                                  ; and report failure to the user.
  2548                                  ;
  2549 00000E50 59                      		pop cx
  2550 00000E51 36FE0E2565              		dec byte [ss:A20Tries]
  2551 00000E56 75C1                    		jnz .try_enable_a20
  2552                                  
  2553 00000E58 BE[4F18]                		mov si, err_a20
  2554 00000E5B E90A01                  		jmp abort_load
  2555                                  ;
  2556                                  ; A20 unmasked, proceed...
  2557                                  ;
  2558 00000E5E 59                      .a20_done:	pop cx
  2559 00000E5F C3                      		ret
  2560                                  
  2561                                  ;
  2562                                  ; This routine tests if A20 is enabled (ZF = 0).  This routine
  2563                                  ; must not destroy any register contents.
  2564                                  ;
  2565                                  a20_test:
  2566 00000E60 06                      		push es
  2567 00000E61 51                      		push cx
  2568 00000E62 50                      		push ax
  2569 00000E63 B9FFFF                  		mov cx,0FFFFh		; HMA = segment 0FFFFh
  2570 00000E66 8EC0                    		mov es,ax
  2571 00000E68 B90001                  		mov cx,0100h		; Loop count
  2572 00000E6B 36A11865                		mov ax,[ss:A20Test]
  2573 00000E6F 40                      .a20_wait:	inc ax
  2574 00000E70 36A31865                		mov [ss:A20Test],ax
  2575 00000E74 E85B00                  		call try_wbinvd
  2576 00000E77 263B062865              		cmp ax,[es:A20Test+10h]
  2577 00000E7C E1F1                    		loopz .a20_wait
  2578 00000E7E 58                      .a20_done:	pop ax
  2579 00000E7F 59                      		pop cx
  2580 00000E80 07                      		pop es
  2581 00000E81 C3                      		ret
  2582                                  
  2583                                  disable_a20:
  2584                                  ;
  2585                                  ; Flush the caches
  2586                                  ;
  2587 00000E82 E84D00                  		call try_wbinvd
  2588                                  ;
  2589                                  ; Disable the "fast A20 gate"
  2590                                  ;
  2591 00000E85 E492                    		in al, 092h
  2592 00000E87 24FC                    		and al,~03h
  2593 00000E89 E692                    		out 092h, al
  2594                                  ;
  2595                                  ; Disable the keyboard controller A20 gate
  2596                                  ;
  2597 00000E8B 36F606266501            		test [ss:A20KBCflag], byte 01h
  2598 00000E91 7411                    		jz .snooze		; Never messed with the KBC
  2599                                  
  2600                                  		; We did mess with the KBC, so we have to do this..
  2601 00000E93 E81900                  		call empty_8042_uncond
  2602 00000E96 B0D1                    		mov al,0D1h
  2603 00000E98 E664                    		out 064h, al		; Command write
  2604 00000E9A E81200                  		call empty_8042_uncond
  2605 00000E9D B0DD                    		mov al,0DDh		; A20 off
  2606 00000E9F E660                    		out 060h, al
  2607 00000EA1 E80B00                  		call empty_8042_uncond
  2608                                  		; Wait a bit for it to take effect
  2609 00000EA4 51                      .snooze:	push cx
  2610 00000EA5 B90004                  		mov cx, delaytime
  2611 00000EA8 E85FFF                  .delayloop:	io_delay
  2612 00000EAB E2FB                    		loop .delayloop
  2613 00000EAD 59                      		pop cx
  2614 00000EAE C3                      		ret
  2615                                  
  2616                                  ;
  2617                                  ; Routine to empty the 8042 KBC controller.  If dl != 0
  2618                                  ; then we will test A20 in the loop and exit if A20 is
  2619                                  ; suddenly enabled.
  2620                                  ;
  2621                                  empty_8042_uncond:
  2622 00000EAF 30D2                    		xor dl,dl
  2623                                  empty_8042:
  2624 00000EB1 E8ACFF                  		call a20_test
  2625 00000EB4 7404                    		jz .a20_on
  2626 00000EB6 20D2                    		and dl,dl
  2627 00000EB8 7517                    		jnz .done
  2628 00000EBA E84DFF                  .a20_on:	io_delay
  2629 00000EBD E464                    		in al, 064h		; Status port
  2630 00000EBF A801                    		test al,1
  2631 00000EC1 7407                    		jz .no_output
  2632 00000EC3 E844FF                  		io_delay
  2633 00000EC6 E460                    		in al, 060h		; Read input
  2634 00000EC8 EBE7                    		jmp short empty_8042
  2635                                  .no_output:
  2636 00000ECA A802                    		test al,2
  2637 00000ECC 75E3                    		jnz empty_8042
  2638 00000ECE E839FF                  		io_delay
  2639 00000ED1 C3                      .done:		ret	
  2640                                  
  2641                                  ;
  2642                                  ; WBINVD instruction; gets auto-eliminated on 386 CPUs
  2643                                  ;
  2644                                  try_wbinvd:
  2645 00000ED2 0F09                    		wbinvd
  2646 00000ED4 C3                      		ret
  2647                                  
  2648                                  ;
  2649                                  ; Load RAM disk into high memory
  2650                                  ;
  2651                                  loadinitrd:
  2652 00000ED5 06                                      push es                         ; Save ES on entry
  2653 00000ED6 B80070                                  mov ax,real_mode_seg
  2654 00000ED9 8EC0                                    mov es,ax
  2655 00000EDB 8B36[2E19]                              mov si,[initrd_ptr]
  2656 00000EDF 668B3EC064                              mov edi,[InitRDat]		; initrd load address
  2657 00000EE4 2666893E1802            		mov [es:su_ramdiskat],edi	; Offset for ram disk
  2658 00000EEA 56                      		push si
  2659 00000EEB BE4B65                                  mov si,InitRDCName		; Write ramdisk name
  2660 00000EEE E8C902                                  call cwritestr
  2661 00000EF1 BE[C118]                                mov si,dotdot_msg		; Write dots
  2662 00000EF4 E8C302                                  call cwritestr
  2663                                  rd_load_loop:	
  2664 00000EF7 BE[C218]                		mov si,dot_msg			; Progress report
  2665 00000EFA E8BD02                                  call cwritestr
  2666 00000EFD 5E                      		pop si				; Restore cluster pointer
  2667 00000EFE E85300                                  call abort_check
  2668 00000F01 8B0E0265                                mov cx,[InitRDClust]
  2669 00000F05 3B0E0465                		cmp cx,[ClustPerMoby]
  2670 00000F09 7604                    		jna rd_last_moby
  2671 00000F0B 8B0E0465                		mov cx,[ClustPerMoby]
  2672                                  rd_last_moby:
  2673 00000F0F 290E0265                		sub [InitRDClust],cx
  2674 00000F13 31DB                    		xor bx,bx			; Load at offset 0
  2675 00000F15 680030                                  push word xfer_buf_seg		; Bounce buffer segment
  2676 00000F18 07                      		pop es
  2677 00000F19 51                      		push cx
  2678 00000F1A E809F4                  		call getfssec
  2679 00000F1D 59                      		pop cx
  2680 00000F1E 56                                      push si				; Save cluster pointer
  2681 00000F1F 66BE00000300            		mov esi,(xfer_buf_seg << 4)
  2682 00000F25 668B3EC064              		mov edi,[InitRDat]
  2683 00000F2A 66B900400000            		mov ecx,4000h			; Copy 64K
  2684 00000F30 E881FE                  		call bcopy			; Does not change flags!!
  2685 00000F33 7210                                    jc rd_load_done                 ; EOF?
  2686 00000F35 668106C06400000100                      add dword [InitRDat],10000h	; Point to next 64K
  2687 00000F3E 833E026500              		cmp word [InitRDClust],byte 0	; Are we done?
  2688 00000F43 75B2                    		jne rd_load_loop		; Apparently not
  2689                                  rd_load_done:
  2690 00000F45 5E                                      pop si                          ; Clean up the stack
  2691 00000F46 BE[CD18]                                mov si,crlf_msg
  2692 00000F49 E86E02                  		call cwritestr
  2693 00000F4C BE[B818]                                mov si,loading_msg		; Write new "Loading " for
  2694 00000F4F E86802                                  call cwritestr                  ; the benefit of the kernel
  2695 00000F52 07                                      pop es                          ; Restore original ES
  2696 00000F53 C3                                      ret
  2697                                  
  2698                                  ;
  2699                                  ; abort_check: let the user abort with <ESC> or <Ctrl-C>
  2700                                  ;
  2701                                  abort_check:
  2702 00000F54 E87002                  		call pollchar
  2703 00000F57 7423                    		jz ac_ret1
  2704 00000F59 60                      		pusha
  2705 00000F5A E88102                  		call getchar
  2706 00000F5D 3C1B                    		cmp al,27			; <ESC>
  2707 00000F5F 7404                    		je ac_kill
  2708 00000F61 3C03                    		cmp al,3			; <Ctrl-C>
  2709 00000F63 7516                    		jne ac_ret2
  2710 00000F65 BE[C418]                ac_kill:	mov si,aborted_msg
  2711                                  
  2712                                  ;
  2713                                  ; abort_load: Called by various routines which wants to print a fatal
  2714                                  ;             error message and return to the command prompt.  Since this
  2715                                  ;             may happen at just about any stage of the boot process, assume
  2716                                  ;             our state is messed up, and just reset the segment registers
  2717                                  ;             and the stack forcibly.
  2718                                  ;
  2719                                  ;             SI    = offset (in _text) of error message to print
  2720                                  ;
  2721                                  abort_load:
  2722 00000F68 8CC8                                    mov ax,cs                       ; Restore CS = DS = ES
  2723 00000F6A 8ED8                                    mov ds,ax
  2724 00000F6C 8EC0                                    mov es,ax
  2725 00000F6E FA                                      cli
  2726 00000F6F BCFA5F                                  mov sp,StackBuf-2*3    		; Reset stack
  2727 00000F72 8ED0                                    mov ss,ax                       ; Just in case...
  2728 00000F74 FB                                      sti
  2729 00000F75 E84202                                  call cwritestr                  ; Expects SI -> error msg
  2730 00000F78 E914F7                  al_ok:          jmp enter_command               ; Return to command prompt
  2731                                  ;
  2732                                  ; End of abort_check
  2733                                  ;
  2734 00000F7B 61                      ac_ret2:	popa
  2735 00000F7C C3                      ac_ret1:	ret
  2736                                  
  2737                                  ;
  2738                                  ; searchdir: Search the root directory for a pre-mangled filename in
  2739                                  ;	     DS:DI.  This routine is similar to the one in the boot
  2740                                  ;	     sector, but is a little less Draconian when it comes to
  2741                                  ;	     error handling, plus it reads the root directory in
  2742                                  ;	     larger chunks than a sector at a time (which is probably
  2743                                  ;	     a waste of coding effort, but I like to do things right).
  2744                                  ;
  2745                                  ;	     FIXME: usually we can load the entire root dir in memory,
  2746                                  ;	     and files are usually at the beginning anyway.  It probably
  2747                                  ;	     would be worthwhile to remember if we have the first chunk
  2748                                  ;	     in memory and skip the load if that (it would speed up online
  2749                                  ;	     help, mainly.)
  2750                                  ;
  2751                                  ;	     NOTE: This file considers finding a zero-length file an
  2752                                  ;	     error.  This is so we don't have to deal with that special
  2753                                  ;	     case elsewhere in the program (most loops have the test
  2754                                  ;	     at the end).
  2755                                  ;
  2756                                  ;	     If successful:
  2757                                  ;		ZF clear
  2758                                  ;		SI	= cluster # for the first cluster
  2759                                  ;		DX:AX	= file length in bytes
  2760                                  ;	     If unsuccessful
  2761                                  ;		ZF set
  2762                                  ;
  2763                                  
  2764                                  searchdir:
  2765 00000F7D A1[1100]                		mov ax,[bsRootDirEnts]
  2766 00000F80 A3EA64                  		mov [DirScanCtr],ax
  2767 00000F83 A1E864                  		mov ax,[RootDirSize]
  2768 00000F86 A3EC64                  		mov [DirBlocksLeft],ax
  2769 00000F89 A1DC64                  		mov ax,[RootDir1]
  2770 00000F8C 8B16DE64                		mov dx,[RootDir2]
  2771                                  scan_group:
  2772 00000F90 8B2EEC64                		mov bp,[DirBlocksLeft]
  2773 00000F94 21ED                    		and bp,bp
  2774 00000F96 7467                    		jz dir_return
  2775 00000F98 3B2EFA64                		cmp bp,[BufSafeSec]
  2776 00000F9C 7604                    		jna load_last
  2777 00000F9E 8B2EFA64                		mov bp,[BufSafeSec]
  2778                                  load_last:
  2779 00000FA2 292EEC64                		sub [DirBlocksLeft],bp
  2780 00000FA6 50                      		push ax
  2781 00000FA7 52                      		push dx
  2782 00000FA8 A1[0B00]                		mov ax,[bsBytesPerSec]
  2783 00000FAB F7E5                    		mul bp
  2784 00000FAD 05E10F                  		add ax,trackbuf-31
  2785 00000FB0 A3EE64                  		mov [EndofDirSec],ax	; End of loaded
  2786 00000FB3 5A                      		pop dx
  2787 00000FB4 58                      		pop ax
  2788 00000FB5 55                      		push bp			; Save number of sectors
  2789 00000FB6 50                      		push ax			; Save present location
  2790 00000FB7 52                      		push dx
  2791 00000FB8 57                      		push di			; Save name
  2792 00000FB9 BB0010                  		mov bx,trackbuf
  2793 00000FBC E8B2F1                  		call getlinsec
  2794 00000FBF 5F                      		pop di
  2795 00000FC0 5A                      		pop dx
  2796 00000FC1 58                      		pop ax
  2797 00000FC2 5D                      		pop bp
  2798 00000FC3 BE0010                  		mov si,trackbuf
  2799 00000FC6 803C00                  dir_test_name:	cmp byte [si],0		; Directory high water mark
  2800 00000FC9 7434                    		je dir_return		; Failed
  2801 00000FCB F6440B18                                test byte [si+11],18h	; Check it really is a file
  2802 00000FCF 750B                                    jnz dir_not_this
  2803 00000FD1 57                      		push di
  2804 00000FD2 56                      		push si
  2805 00000FD3 B90B00                  		mov cx,11		; Filename = 11 bytes
  2806 00000FD6 F3A6                    		repe cmpsb
  2807 00000FD8 5E                      		pop si
  2808 00000FD9 5F                      		pop di
  2809 00000FDA 7416                    		je dir_success
  2810 00000FDC 83C620                  dir_not_this:   add si,byte 32
  2811 00000FDF FF0EEA64                		dec word [DirScanCtr]
  2812 00000FE3 741A                    		jz dir_return		; Out of it...
  2813 00000FE5 3B36EE64                		cmp si,[EndofDirSec]
  2814 00000FE9 72DB                    		jb dir_test_name
  2815 00000FEB 01E8                    		add ax,bp		; Increment linear sector number
  2816 00000FED 83D200                  		adc dx,byte 0
  2817 00000FF0 EB9E                    		jmp short scan_group
  2818                                  dir_success:
  2819 00000FF2 8B441C                  		mov ax,[si+28]		; Length of file
  2820 00000FF5 8B541E                  		mov dx,[si+30]
  2821 00000FF8 8B741A                  		mov si,[si+26]		; Cluster pointer
  2822 00000FFB 89C3                    		mov bx,ax
  2823 00000FFD 09D3                    		or bx,dx		; Sets ZF iff DX:AX is zero
  2824                                  dir_return:
  2825 00000FFF C3                      		ret
  2826                                  
  2827                                  ;
  2828                                  ; adjust_screen: Set the internal variables associated with the screen size.
  2829                                  ;		This is a subroutine in case we're loading a custom font.
  2830                                  ;
  2831                                  adjust_screen:
  2832 00001000 A08404                                  mov al,[BIOS_vidrows]
  2833 00001003 20C0                                    and al,al
  2834 00001005 7502                                    jnz vidrows_is_ok
  2835 00001007 B018                                    mov al,24                       ; No vidrows in BIOS, assume 25
  2836                                  						; (Remember: vidrows == rows-1)
  2837 00001009 A22165                  vidrows_is_ok:  mov [VidRows],al
  2838 0000100C B40F                                    mov ah,0fh
  2839 0000100E CD10                                    int 10h                         ; Read video state
  2840 00001010 883E1D65                                mov [TextPage],bh
  2841 00001014 FECC                                    dec ah                          ; Store count-1 (same as rows)
  2842 00001016 88262065                                mov [VidCols],ah
  2843 0000101A C3                      bf_ret:		ret
  2844                                  
  2845                                  ;
  2846                                  ; loadfont:	Load a .psf font file and install it onto the VGA console
  2847                                  ;		(if we're not on a VGA screen then ignore.)  It is called with
  2848                                  ;		SI and DX:AX set by routine searchdir
  2849                                  ;
  2850                                  loadfont:
  2851 0000101B BB0010                  		mov bx,trackbuf			; The trackbuf is >= 16K; the part
  2852 0000101E 8B0EF864                		mov cx,[BufSafe]		; of a PSF file we care about is no
  2853 00001022 E801F3                  		call getfssec			; more than 8K+4 bytes
  2854                                  
  2855 00001025 A10010                  		mov ax,[trackbuf]		; Magic number
  2856 00001028 3D3604                  		cmp ax,0436h
  2857 0000102B 75ED                    		jne bf_ret
  2858                                  
  2859 0000102D A00210                  		mov al,[trackbuf+2]		; File mode
  2860 00001030 3C03                    		cmp al,3			; Font modes 0-3 supported
  2861 00001032 77E6                    		ja bf_ret
  2862                                  
  2863 00001034 8A3E0310                		mov bh,byte [trackbuf+3]	; Height of font
  2864 00001038 80FF02                  		cmp bh,2			; VGA minimum
  2865 0000103B 72DD                    		jb bf_ret
  2866 0000103D 80FF20                  		cmp bh,32			; VGA maximum
  2867 00001040 77D8                    		ja bf_ret
  2868                                  
  2869 00001042 BD0410                  		mov bp,trackbuf+4		; Address of font data
  2870 00001045 30DB                    		xor bl,bl
  2871 00001047 B90001                  		mov cx,256
  2872 0000104A 31D2                    		xor dx,dx
  2873 0000104C B81011                  		mov ax,1110h
  2874 0000104F CD10                    		int 10h				; Load into VGA RAM
  2875                                  
  2876 00001051 30DB                    		xor bl,bl
  2877 00001053 B80311                  		mov ax,1103h			; Select page 0
  2878 00001056 CD10                    		int 10h
  2879                                  
  2880 00001058 EBA6                    		jmp short adjust_screen
  2881                                  
  2882                                  ;
  2883                                  ; loadkeys:	Load a LILO-style keymap; SI and DX:AX set by searchdir
  2884                                  ;
  2885                                  loadkeys:
  2886 0000105A 21D2                    		and dx,dx			; Should be 256 bytes exactly
  2887 0000105C 751A                    		jne loadkeys_ret
  2888 0000105E 3D0001                  		cmp ax,256
  2889 00001061 7515                    		jne loadkeys_ret
  2890                                  
  2891 00001063 BB0010                  		mov bx,trackbuf
  2892 00001066 B90100                  		mov cx,1			; 1 cluster should be >= 256 bytes
  2893 00001069 E8BAF2                  		call getfssec
  2894                                  
  2895 0000106C BE0010                  		mov si,trackbuf
  2896 0000106F BF0063                  		mov di,KbdMap
  2897 00001072 B94000                  		mov cx,256 >> 2
  2898 00001075 F366A5                  		rep movsd
  2899                                  
  2900 00001078 C3                      loadkeys_ret:	ret
  2901                                  		
  2902                                  ;
  2903                                  ; get_msg_file: Load a text file and write its contents to the screen,
  2904                                  ;               interpreting color codes.  Is called with SI and DX:AX
  2905                                  ;               set by routine searchdir
  2906                                  ;
  2907                                  get_msg_file:
  2908 00001079 C7061265[CD10]                          mov word [NextCharJump],msg_putchar ; State machine for color
  2909 0000107F C6061C6507                              mov byte [TextAttribute],07h	; Default grey on white
  2910 00001084 60                                      pusha
  2911 00001085 8A3E1D65                                mov bh,[TextPage]
  2912 00001089 B403                                    mov ah,03h                      ; Read cursor position
  2913 0000108B CD10                                    int 10h
  2914 0000108D 89161E65                                mov [CursorDX],dx
  2915 00001091 61                                      popa
  2916 00001092 50                      get_msg_chunk:  push ax                         ; DX:AX = length of file
  2917 00001093 52                                      push dx
  2918 00001094 BB0010                  		mov bx,trackbuf
  2919 00001097 8B0EF864                		mov cx,[BufSafe]
  2920 0000109B E888F2                  		call getfssec
  2921 0000109E 5A                                      pop dx
  2922 0000109F 58                                      pop ax
  2923 000010A0 56                      		push si				; Save current cluster
  2924 000010A1 BE0010                  		mov si,trackbuf
  2925 000010A4 8B0EFC64                		mov cx,[BufSafeBytes]		; No more than many bytes
  2926 000010A8 51                      print_msg_file: push cx
  2927 000010A9 50                                      push ax
  2928 000010AA 52                      		push dx
  2929 000010AB AC                      		lodsb
  2930 000010AC 3C1A                                    cmp al,1Ah                      ; ASCII EOF?
  2931 000010AE 7418                    		je msg_done_pop
  2932 000010B0 FF161265                                call [NextCharJump]		; Do what shall be done
  2933 000010B4 5A                      		pop dx
  2934 000010B5 58                      		pop ax
  2935 000010B6 59                                      pop cx
  2936 000010B7 83E801                  		sub ax,byte 1
  2937 000010BA 83DA00                  		sbb dx,byte 0
  2938 000010BD 89C3                    		mov bx,ax
  2939 000010BF 09D3                    		or bx,dx
  2940 000010C1 7408                    		jz msg_done
  2941 000010C3 E2E3                    		loop print_msg_file
  2942 000010C5 5E                      		pop si
  2943 000010C6 EBCA                    		jmp short get_msg_chunk
  2944                                  msg_done_pop:
  2945 000010C8 83C406                                  add sp,byte 6			; Lose 3 words on the stack
  2946                                  msg_done:
  2947 000010CB 5E                      		pop si
  2948 000010CC C3                      		ret
  2949                                  msg_putchar:                                    ; Normal character
  2950 000010CD 3C0F                                    cmp al,0Fh                      ; ^O = color code follows
  2951 000010CF 7434                                    je msg_ctrl_o
  2952 000010D1 3C0D                                    cmp al,0Dh                      ; Ignore <CR>
  2953 000010D3 742F                                    je msg_ignore
  2954 000010D5 3C0A                                    cmp al,0Ah                      ; <LF> = newline
  2955 000010D7 7433                                    je msg_newline
  2956 000010D9 3C0C                                    cmp al,0Ch                      ; <FF> = clear screen
  2957 000010DB 7460                                    je msg_formfeed
  2958                                  
  2959 000010DD E8A800                  msg_normal:	call write_serial		; Write to serial port
  2960 000010E0 8B1E1C65                                mov bx,[TextAttrBX]
  2961 000010E4 B409                                    mov ah,09h                      ; Write character/attribute
  2962 000010E6 B90100                                  mov cx,1                        ; One character only
  2963 000010E9 CD10                                    int 10h                         ; Write to screen
  2964 000010EB A01E65                                  mov al,[CursorCol]
  2965 000010EE 40                                      inc ax
  2966 000010EF 3A062065                                cmp al,[VidCols]
  2967 000010F3 7717                                    ja msg_newline
  2968 000010F5 A21E65                                  mov [CursorCol],al
  2969                                  
  2970 000010F8 8A3E1D65                msg_gotoxy:     mov bh,[TextPage]
  2971 000010FC 8B161E65                                mov dx,[CursorDX]
  2972 00001100 B402                                    mov ah,02h                      ; Set cursor position
  2973 00001102 CD10                                    int 10h
  2974 00001104 C3                      msg_ignore:     ret
  2975                                  msg_ctrl_o:                                     ; ^O = color code follows
  2976 00001105 C7061265[5A11]                          mov word [NextCharJump],msg_setbg
  2977 0000110B C3                                      ret
  2978                                  msg_newline:                                    ; Newline char or end of line
  2979 0000110C 56                      		push si
  2980 0000110D BE[CD18]                		mov si,crlf_msg
  2981 00001110 E88F00                  		call write_serial_str
  2982 00001113 5E                      		pop si
  2983 00001114 C6061E6500                              mov byte [CursorCol],0
  2984 00001119 A01F65                                  mov al,[CursorRow]
  2985 0000111C 40                                      inc ax
  2986 0000111D 3A062165                                cmp al,[VidRows]
  2987 00001121 7705                                    ja msg_scroll
  2988 00001123 A21F65                                  mov [CursorRow],al
  2989 00001126 EBD0                                    jmp short msg_gotoxy
  2990 00001128 31C9                    msg_scroll:     xor cx,cx                       ; Upper left hand corner
  2991 0000112A 8B162065                                mov dx,[ScreenSize]
  2992 0000112E 88361F65                                mov [CursorRow],dh		; New cursor at the bottom
  2993 00001132 8A3E1C65                                mov bh,[TextAttribute]
  2994 00001136 B80106                                  mov ax,0601h                    ; Scroll up one line
  2995 00001139 CD10                                    int 10h
  2996 0000113B EBBB                                    jmp short msg_gotoxy
  2997                                  msg_formfeed:                                   ; Form feed character
  2998 0000113D 56                      		push si
  2999 0000113E BE[D018]                		mov si,crff_msg
  3000 00001141 E85E00                  		call write_serial_str
  3001 00001144 5E                      		pop si
  3002 00001145 31C9                                    xor cx,cx
  3003 00001147 890E1E65                                mov [CursorDX],cx		; Upper lefthand corner
  3004 0000114B 8B162065                                mov dx,[ScreenSize]
  3005 0000114F 8A3E1C65                                mov bh,[TextAttribute]
  3006 00001153 B80006                                  mov ax,0600h                    ; Clear screen region
  3007 00001156 CD10                                    int 10h
  3008 00001158 EB9E                                    jmp short msg_gotoxy
  3009                                  msg_setbg:                                      ; Color background character
  3010 0000115A E84802                                  call unhexchar
  3011 0000115D 721D                                    jc msg_color_bad
  3012 0000115F C0E004                                  shl al,4
  3013 00001162 A21C65                                  mov [TextAttribute],al
  3014 00001165 C7061265[6C11]                          mov word [NextCharJump],msg_setfg
  3015 0000116B C3                                      ret
  3016                                  msg_setfg:                                      ; Color foreground character
  3017 0000116C E83602                                  call unhexchar
  3018 0000116F 720B                                    jc msg_color_bad
  3019 00001171 08061C65                                or [TextAttribute],al		; setbg set foreground to 0
  3020 00001175 C7061265[CD10]                          mov word [NextCharJump],msg_putchar
  3021 0000117B C3                                      ret
  3022                                  msg_color_bad:
  3023 0000117C C6061C6507                              mov byte [TextAttribute],07h	; Default attribute
  3024 00001181 C7061265[CD10]                          mov word [NextCharJump],msg_putchar
  3025 00001187 C3                                      ret
  3026                                  
  3027                                  ;
  3028                                  ; write_serial:	If serial output is enabled, write character on serial port
  3029                                  ;
  3030                                  write_serial:
  3031 00001188 60                      		pusha
  3032 00001189 8B1E[3619]              		mov bx,[SerialPort]
  3033 0000118D 21DB                    		and bx,bx
  3034 0000118F 740F                    		je .noserial
  3035 00001191 50                      		push ax
  3036 00001192 8D5705                  .waitspace:	lea dx,[bx+5]			; Wait for space in transmit reg
  3037 00001195 EC                      		in al,dx
  3038 00001196 A820                    		test al,20h
  3039 00001198 74F8                    		jz .waitspace
  3040 0000119A 87DA                    		xchg dx,bx
  3041 0000119C 58                      		pop ax
  3042 0000119D E869FC                  		call slow_out			; Send data
  3043 000011A0 61                      .noserial:	popa
  3044 000011A1 C3                      		ret
  3045                                  
  3046                                  ;
  3047                                  ; write_serial_str: write_serial for strings
  3048                                  ;
  3049                                  write_serial_str:
  3050 000011A2 AC                      .loop		lodsb
  3051 000011A3 20C0                    		and al,al
  3052 000011A5 7405                    		jz .end
  3053 000011A7 E8DEFF                  		call write_serial
  3054 000011AA EBF6                    		jmp short .loop
  3055 000011AC C3                      .end:		ret
  3056                                  
  3057                                  ;
  3058                                  ; writechr:	Write a single character in AL to the console without
  3059                                  ;		mangling any registers
  3060                                  ;
  3061                                  writechr:
  3062 000011AD E8D8FF                  		call write_serial	; write to serial port if needed
  3063 000011B0 60                      		pusha
  3064 000011B1 B40E                    		mov ah,0Eh
  3065 000011B3 BB0700                  		mov bx,0007h		; white text on this page
  3066 000011B6 CD10                    		int 10h
  3067 000011B8 61                      		popa
  3068 000011B9 C3                      		ret
  3069                                  
  3070                                  ;
  3071                                  ; cwritestr: write a null-terminated string to the console, saving
  3072                                  ;            registers on entry.
  3073                                  ;
  3074                                  cwritestr:
  3075 000011BA 60                                      pusha
  3076 000011BB AC                      .top:		lodsb
  3077 000011BC 20C0                    		and al,al
  3078 000011BE 7405                                    jz .end
  3079 000011C0 E8EAFF                  		call writechr
  3080 000011C3 EBF6                                    jmp short .top
  3081 000011C5 61                      .end:		popa
  3082 000011C6 C3                                      ret
  3083                                  
  3084                                  ;
  3085                                  ; pollchar: check if we have an input character pending (ZF = 0)
  3086                                  ;
  3087                                  pollchar:
  3088 000011C7 60                      		pusha
  3089 000011C8 B401                    		mov ah,1		; Poll keyboard
  3090 000011CA CD16                    		int 16h
  3091 000011CC 750E                    		jnz .done		; Keyboard response
  3092 000011CE 8B16[3619]              		mov dx,[SerialPort]
  3093 000011D2 21D2                    		and dx,dx
  3094 000011D4 7406                    		jz .done		; No serial port -> no input
  3095 000011D6 83C205                  		add dx,byte 5		; Serial status register
  3096 000011D9 EC                      		in al,dx
  3097 000011DA A801                    		test al,1		; ZF = 0 if traffic
  3098 000011DC 61                      .done:		popa
  3099 000011DD C3                      		ret
  3100                                  
  3101                                  ;
  3102                                  ; getchar: Read a character from keyboard or serial port
  3103                                  ;
  3104                                  getchar:
  3105 000011DE B401                    .again:		mov ah,1		; Poll keyboard
  3106 000011E0 CD16                    		int 16h
  3107 000011E2 7516                    		jnz .kbd		; Keyboard input?
  3108 000011E4 8B1E[3619]              		mov bx,[SerialPort]
  3109 000011E8 21DB                    		and bx,bx
  3110 000011EA 74F2                    		jz .again
  3111 000011EC 8D5705                  		lea dx,[bx+5]		; Serial status register
  3112 000011EF EC                      		in al,dx
  3113 000011F0 A801                    		test al,1
  3114 000011F2 74EA                    		jz .again
  3115 000011F4 30E4                    .serial:	xor ah,ah		; Avoid confusion
  3116 000011F6 87DA                    		xchg dx,bx		; Data port
  3117 000011F8 EC                      		in al,dx
  3118 000011F9 C3                      		ret
  3119 000011FA 31C0                    .kbd:		xor ax,ax		; Get keyboard input
  3120 000011FC CD16                    		int 16h
  3121 000011FE 20C0                    		and al,al
  3122 00001200 7404                    		jz .func_key
  3123 00001202 BB0063                  		mov bx,KbdMap		; Convert character sets
  3124 00001205 D7                      		xlatb
  3125 00001206 C3                      .func_key:	ret
  3126                                  
  3127                                  ;
  3128                                  ;
  3129                                  ; kaboom2: once everything is loaded, replace the part of kaboom
  3130                                  ;	   starting with "kaboom.patch" with this part
  3131                                  
  3132                                  kaboom2:
  3133 00001207 BE[6C18]                		mov si,err_bootfailed
  3134 0000120A E8ADFF                  		call cwritestr
  3135 0000120D E8CEFF                  		call getchar
  3136 00001210 CD19                    		int 19h			; And try once more to boot...
  3137 00001212 EBFE                    .norge:		jmp short .norge	; If int 19h returned; this is the end
  3138                                  
  3139                                  ;
  3140                                  ; open,getc:	Load a file a character at a time for parsing in a manner
  3141                                  ;		similar to the C library getc routine.	Only one simultaneous
  3142                                  ;		use is supported.  Note: "open" trashes the trackbuf.
  3143                                  ;
  3144                                  ;		open:	Input:	mangled filename in DS:DI
  3145                                  ;			Output: ZF set on file not found or zero length
  3146                                  ;
  3147                                  ;		getc:	Output: CF set on end of file
  3148                                  ;				Character loaded in AL
  3149                                  ;
  3150                                  open:
  3151 00001214 E866FD                  		call searchdir
  3152 00001217 7427                    		jz open_return
  3153 00001219 9C                      		pushf
  3154 0000121A A3E464                  		mov [FBytes1],ax
  3155 0000121D 8916E664                		mov [FBytes2],dx
  3156 00001221 0306F264                		add ax,[ClustSize]
  3157 00001225 83D200                  		adc dx,byte 0
  3158 00001228 83E801                  		sub ax,byte 1
  3159 0000122B 83DA00                  		sbb dx,byte 0
  3160 0000122E F736F264                		div word [ClustSize]
  3161 00001232 A30665                  		mov [FClust],ax		; Number of clusters
  3162 00001235 89360865                		mov [FNextClust],si	; Cluster pointer
  3163 00001239 A1FE64                  		mov ax,[EndOfGetCBuf]	; Pointer at end of buffer ->
  3164 0000123C A30A65                  		mov [FPtr],ax		;  nothing loaded yet
  3165 0000123F 9D                      		popf			; Restore no ZF
  3166 00001240 C3                      open_return:	ret
  3167                                  
  3168                                  ;
  3169                                  getc:
  3170 00001241 F9                      		stc			; If we exit here -> EOF
  3171 00001242 668B0EE464              		mov ecx,[FBytes]
  3172 00001247 67E33B                  		jecxz getc_ret
  3173 0000124A 8B360A65                		mov si,[FPtr]
  3174 0000124E 3B36FE64                		cmp si,[EndOfGetCBuf]
  3175 00001252 7226                    		jb getc_loaded
  3176                                  		; Buffer empty -- load another set
  3177 00001254 8B0E0665                		mov cx,[FClust]
  3178 00001258 3B0EF864                		cmp cx,[BufSafe]
  3179 0000125C 7604                    		jna getc_oksize
  3180 0000125E 8B0EF864                		mov cx,[BufSafe]
  3181 00001262 290E0665                getc_oksize:	sub [FClust],cx		; Reduce remaining clusters
  3182 00001266 8B360865                		mov si,[FNextClust]
  3183 0000126A BB0098                  		mov bx,getcbuf
  3184 0000126D 53                      		push bx
  3185 0000126E 06                      		push es			; ES may be != DS, save old ES
  3186 0000126F 1E                      		push ds			; Trackbuf is in DS, not ES
  3187 00001270 07                      		pop es
  3188 00001271 E8B2F0                  		call getfssec		; Load a trackbuf full of data
  3189 00001274 89360865                		mov [FNextClust],si	; Store new next pointer
  3190 00001278 07                      		pop es			; Restore ES
  3191 00001279 5E                      		pop si			; SI -> newly loaded data
  3192 0000127A AC                      getc_loaded:	lodsb			; Load a byte
  3193 0000127B 89360A65                		mov [FPtr],si		; Update next byte pointer
  3194 0000127F 66FF0EE464              		dec dword [FBytes]	; Update bytes left counter (CF = 1)
  3195 00001284 F8                      		clc			; Not EOF
  3196 00001285 C3                      getc_ret:	ret
  3197                                  
  3198                                  ;
  3199                                  ; ungetc:	Push a character (in AL) back into the getc buffer
  3200                                  ;		Note: if more than one byte is pushed back, this may cause
  3201                                  ;		bytes to be written below the getc buffer boundary.  If there
  3202                                  ;		is a risk for this to occur, the getcbuf base address should
  3203                                  ;		be moved up.
  3204                                  ;
  3205                                  ungetc:
  3206 00001286 8B360A65                		mov si,[FPtr]
  3207 0000128A 4E                      		dec si
  3208 0000128B 8804                    		mov [si],al
  3209 0000128D 89360A65                		mov [FPtr],si
  3210 00001291 66FF06E464              		inc dword [FBytes]
  3211 00001296 C3                      		ret
  3212                                  
  3213                                  ;
  3214                                  ; skipspace:	Skip leading whitespace using "getc".  If we hit end-of-line
  3215                                  ;		or end-of-file, return with carry set; ZF = true of EOF
  3216                                  ;		ZF = false for EOLN; otherwise CF = ZF = 0.
  3217                                  ;
  3218                                  ;		Otherwise AL = first character after whitespace
  3219                                  ;
  3220                                  skipspace:
  3221 00001297 E8A7FF                  skipspace_loop: call getc
  3222 0000129A 720D                    		jc skipspace_eof
  3223 0000129C 3C1A                    		cmp al,1Ah			; DOS EOF
  3224 0000129E 7409                    		je skipspace_eof
  3225 000012A0 3C0A                    		cmp al,0Ah
  3226 000012A2 7409                    		je skipspace_eoln
  3227 000012A4 3C20                    		cmp al,' '
  3228 000012A6 76EF                    		jbe skipspace_loop
  3229 000012A8 C3                      		ret				; CF = ZF = 0
  3230 000012A9 38C0                    skipspace_eof:	cmp al,al			; Set ZF
  3231 000012AB F9                      		stc				; Set CF
  3232 000012AC C3                      		ret
  3233 000012AD 04FF                    skipspace_eoln: add al,0FFh			; Set CF, clear ZF
  3234 000012AF C3                      		ret
  3235                                  
  3236                                  ;
  3237                                  ; getkeyword:	Get a keyword from the current "getc" file; only the two
  3238                                  ;		first characters are considered significant.
  3239                                  ;
  3240                                  ;		Lines beginning with ASCII characters 33-47 are treated
  3241                                  ;		as comments and ignored; other lines are checked for
  3242                                  ;		validity by scanning through the keywd_table.
  3243                                  ;
  3244                                  ;		The keyword and subsequent whitespace is skipped.
  3245                                  ;
  3246                                  ;		On EOF, CF = 1; otherwise, CF = 0, AL:AH = lowercase char pair
  3247                                  ;
  3248                                  getkeyword:
  3249 000012B0 E8E4FF                  gkw_find:	call skipspace
  3250 000012B3 7438                    		jz gkw_eof		; end of file
  3251 000012B5 72F9                    		jc gkw_find		; end of line: try again
  3252 000012B7 3C30                    		cmp al,'0'
  3253 000012B9 7245                    		jb gkw_skipline		; skip comment line
  3254 000012BB 50                      		push ax
  3255 000012BC E882FF                  		call getc
  3256 000012BF 5B                      		pop bx
  3257 000012C0 722B                    		jc gkw_eof
  3258 000012C2 88C7                    		mov bh,al		; Move character pair into BL:BH
  3259 000012C4 81CB2020                		or bx,2020h		; Lower-case it
  3260 000012C8 BE[E618]                		mov si,keywd_table
  3261 000012CB AD                      gkw_check:	lodsw
  3262 000012CC 21C0                    		and ax,ax
  3263 000012CE 7428                    		jz gkw_badline		; Bad keyword, write message
  3264 000012D0 39D8                    		cmp ax,bx
  3265 000012D2 75F7                    		jne gkw_check
  3266 000012D4 50                      		push ax
  3267                                  gkw_skiprest:
  3268 000012D5 E869FF                  		call getc
  3269 000012D8 7212                    		jc gkw_eof_pop
  3270 000012DA 3C30                    		cmp al,'0'
  3271 000012DC 77F7                    		ja gkw_skiprest
  3272 000012DE E8A5FF                  		call ungetc
  3273 000012E1 E8B3FF                  		call skipspace
  3274 000012E4 7406                    		jz gkw_eof_pop
  3275 000012E6 7206                                    jc gkw_missingpar       ; Missing parameter after keyword
  3276 000012E8 E89BFF                  		call ungetc		; Return character to buffer
  3277 000012EB F8                      		clc			; Successful return
  3278 000012EC 58                      gkw_eof_pop:	pop ax
  3279 000012ED C3                      gkw_eof:	ret			; CF = 1 on all EOF conditions
  3280 000012EE 58                      gkw_missingpar: pop ax
  3281 000012EF BE[2B17]                                mov si,err_noparm
  3282 000012F2 E8C5FE                                  call cwritestr
  3283 000012F5 EBB9                                    jmp gkw_find
  3284 000012F7 58                      gkw_badline_pop: pop ax
  3285 000012F8 BE[0817]                gkw_badline:	mov si,err_badcfg
  3286 000012FB E8BCFE                  		call cwritestr
  3287 000012FE EBB0                    		jmp short gkw_find
  3288 00001300 3C0A                    gkw_skipline:	cmp al,10		; Scan for LF
  3289 00001302 74AC                    		je gkw_find
  3290 00001304 E83AFF                  		call getc
  3291 00001307 72E4                    		jc gkw_eof
  3292 00001309 EBF5                    		jmp short gkw_skipline
  3293                                  
  3294                                  ;
  3295                                  ; getint:	Load an integer from the getc file.
  3296                                  ;		Return CF if error; otherwise return integer in EBX
  3297                                  ;
  3298                                  getint:
  3299 0000130B BFA064                  		mov di,NumBuf
  3300 0000130E 81FFAF64                gi_getnum:	cmp di,NumBufEnd	; Last byte in NumBuf
  3301 00001312 730F                    		jae gi_loaded
  3302 00001314 57                      		push di
  3303 00001315 E829FF                  		call getc
  3304 00001318 5F                      		pop di
  3305 00001319 7208                    		jc gi_loaded
  3306 0000131B AA                      		stosb
  3307 0000131C 3C2D                    		cmp al,'-'
  3308 0000131E 73EE                    		jnb gi_getnum
  3309 00001320 E863FF                  		call ungetc		; Unget non-numeric
  3310 00001323 C60500                  gi_loaded:	mov byte [di],0
  3311 00001326 BEA064                  		mov si,NumBuf
  3312                                  		; Fall through to parseint
  3313                                  
  3314                                  ;
  3315                                  ; parseint:	Convert an integer to a number in EBX
  3316                                  ;		Get characters from string in DS:SI
  3317                                  ;		Return CF on error
  3318                                  ;		DS:SI points to first character after number
  3319                                  ;
  3320                                  ;               Syntaxes accepted: [-]dec, [-]0+oct, [-]0x+hex, val+K, val+M
  3321                                  ;
  3322                                  parseint:
  3323 00001329 6650                                    push eax
  3324 0000132B 6651                                    push ecx
  3325 0000132D 55                      		push bp
  3326 0000132E 6631C0                  		xor eax,eax		; Current digit (keep eax == al)
  3327 00001331 6689C3                  		mov ebx,eax		; Accumulator
  3328 00001334 6689D9                  		mov ecx,ebx		; Base
  3329 00001337 31ED                                    xor bp,bp               ; Used for negative flag
  3330 00001339 AC                      pi_begin:	lodsb
  3331 0000133A 3C2D                    		cmp al,'-'
  3332 0000133C 7505                    		jne pi_not_minus
  3333 0000133E 83F501                  		xor bp,1		; Set unary minus flag
  3334 00001341 EBF6                    		jmp short pi_begin
  3335                                  pi_not_minus:
  3336 00001343 3C30                    		cmp al,'0'
  3337 00001345 724F                    		jb pi_err
  3338 00001347 7408                    		je pi_octhex
  3339 00001349 3C39                    		cmp al,'9'
  3340 0000134B 7749                    		ja pi_err
  3341 0000134D B10A                    		mov cl,10		; Base = decimal
  3342 0000134F EB17                    		jmp short pi_foundbase
  3343                                  pi_octhex:
  3344 00001351 AC                      		lodsb
  3345 00001352 3C30                    		cmp al,'0'
  3346 00001354 7225                    		jb pi_km		; Value is zero
  3347 00001356 0C20                    		or al,20h		; Downcase
  3348 00001358 3C78                    		cmp al,'x'
  3349 0000135A 7408                    		je pi_ishex
  3350 0000135C 3C37                    		cmp al,'7'
  3351 0000135E 7736                    		ja pi_err
  3352 00001360 B108                    		mov cl,8		; Base = octal
  3353 00001362 EB04                    		jmp short pi_foundbase
  3354                                  pi_ishex:
  3355 00001364 B030                    		mov al,'0'		; No numeric value accrued yet
  3356 00001366 B110                    		mov cl,16		; Base = hex
  3357                                  pi_foundbase:
  3358 00001368 E83A00                                  call unhexchar
  3359 0000136B 720E                                    jc pi_km                ; Not a (hex) digit
  3360 0000136D 38C8                                    cmp al,cl
  3361 0000136F 730A                    		jae pi_km		; Invalid for base
  3362 00001371 660FAFD9                		imul ebx,ecx		; Multiply accumulated by base
  3363 00001375 6601C3                                  add ebx,eax             ; Add current digit
  3364 00001378 AC                      		lodsb
  3365 00001379 EBED                    		jmp short pi_foundbase
  3366                                  pi_km:
  3367 0000137B 4E                      		dec si			; Back up to last non-numeric
  3368 0000137C AC                      		lodsb
  3369 0000137D 0C20                    		or al,20h
  3370 0000137F 3C6B                    		cmp al,'k'
  3371 00001381 7416                    		je pi_isk
  3372 00001383 3C6D                    		cmp al,'m'
  3373 00001385 7418                    		je pi_ism
  3374 00001387 4E                      		dec si			; Back up
  3375 00001388 21ED                    pi_fini:	and bp,bp
  3376 0000138A 7404                    		jz pi_ret		; CF=0!
  3377 0000138C 66F7DB                  		neg ebx			; Value was negative
  3378 0000138F F8                      pi_done:	clc
  3379 00001390 5D                      pi_ret:		pop bp
  3380 00001391 6659                                    pop ecx
  3381 00001393 6658                                    pop eax
  3382 00001395 C3                      		ret
  3383 00001396 F9                      pi_err:		stc
  3384 00001397 EBF7                    		jmp short pi_ret
  3385 00001399 66C1E30A                pi_isk:		shl ebx,10		; x 2^10
  3386 0000139D EBF0                    		jmp short pi_done
  3387 0000139F 66C1E314                pi_ism:		shl ebx,20		; x 2^20
  3388 000013A3 EBEA                    		jmp short pi_done
  3389                                  
  3390                                  ;
  3391                                  ; unhexchar:    Convert a hexadecimal digit in AL to the equivalent number;
  3392                                  ;               return CF=1 if not a hex digit
  3393                                  ;
  3394                                  unhexchar:
  3395 000013A5 3C30                                    cmp al,'0'
  3396 000013A7 7215                    		jb uxc_ret		; If failure, CF == 1 already
  3397 000013A9 3C39                                    cmp al,'9'
  3398 000013AB 7703                                    ja uxc_1
  3399 000013AD 2C30                    		sub al,'0'		; CF <- 0
  3400 000013AF C3                      		ret
  3401 000013B0 0C20                    uxc_1:          or al,20h		; upper case -> lower case
  3402 000013B2 3C61                    		cmp al,'a'
  3403 000013B4 7208                                    jb uxc_ret		; If failure, CF == 1 already
  3404 000013B6 3C66                                    cmp al,'f'
  3405 000013B8 7703                                    ja uxc_err
  3406 000013BA 2C57                                    sub al,'a'-10           ; CF <- 0
  3407 000013BC C3                                      ret
  3408 000013BD F9                      uxc_err:        stc
  3409 000013BE C3                      uxc_ret:	ret
  3410                                  
  3411                                  ;
  3412                                  ;
  3413                                  ; getline:	Get a command line, converting control characters to spaces
  3414                                  ;               and collapsing streches to one; a space is appended to the
  3415                                  ;               end of the string, unless the line is empty.
  3416                                  ;		The line is terminated by ^J, ^Z or EOF and is written
  3417                                  ;		to ES:DI.  On return, DI points to first char after string.
  3418                                  ;		CF is set if we hit EOF.
  3419                                  ;
  3420                                  getline:
  3421 000013BF E8D5FE                  		call skipspace
  3422 000013C2 B201                                    mov dl,1                ; Empty line -> empty string.
  3423 000013C4 742B                                    jz gl_eof               ; eof
  3424 000013C6 7226                                    jc gl_eoln              ; eoln
  3425 000013C8 E8BBFE                  		call ungetc
  3426 000013CB 52                      gl_fillloop:	push dx
  3427 000013CC 57                      		push di
  3428 000013CD E871FE                  		call getc
  3429 000013D0 5F                      		pop di
  3430 000013D1 5A                      		pop dx
  3431 000013D2 721E                    		jc gl_ret		; CF set!
  3432 000013D4 3C20                    		cmp al,' '
  3433 000013D6 7605                    		jna gl_ctrl
  3434 000013D8 31D2                    		xor dx,dx
  3435 000013DA AA                      gl_store:	stosb
  3436 000013DB EBEE                    		jmp short gl_fillloop
  3437 000013DD 3C0A                    gl_ctrl:	cmp al,10
  3438 000013DF 7411                    		je gl_ret		; CF clear!
  3439 000013E1 3C1A                    		cmp al,26
  3440 000013E3 740C                    		je gl_eof
  3441 000013E5 20D2                    		and dl,dl
  3442 000013E7 75E2                    		jnz gl_fillloop		; Ignore multiple spaces
  3443 000013E9 B020                    		mov al,' '		; Ctrl -> space
  3444 000013EB 42                      		inc dx
  3445 000013EC EBEC                    		jmp short gl_store
  3446 000013EE F8                      gl_eoln:        clc                     ; End of line is not end of file
  3447 000013EF EB01                                    jmp short gl_ret
  3448 000013F1 F9                      gl_eof:         stc
  3449 000013F2 9C                      gl_ret:		pushf			; We want the last char to be space!
  3450 000013F3 20D2                    		and dl,dl
  3451 000013F5 7503                    		jnz gl_xret
  3452 000013F7 B020                    		mov al,' '
  3453 000013F9 AA                      		stosb
  3454 000013FA 9D                      gl_xret:	popf
  3455 000013FB C3                      		ret
  3456                                  
  3457                                  
  3458                                  %ifdef debug		; This code for debugging only
  3459                                  ;
  3460                                  ; dumpregs:	Dumps the contents of all registers
  3461                                  ;
  3462                                                  assume ds:_text, es:NOTHING, fs:NOTHING, gs:NOTHING
  3463                                  dumpregs	proc near		; When calling, IP is on stack
  3464                                  		pushf			; Store flags
  3465                                  		pusha
  3466                                  		push ds
  3467                                  		push es
  3468                                  		push fs
  3469                                  		push gs
  3470                                  		push cs			; Set DS <- CS
  3471                                  		pop ds
  3472                                  		cld			; Clear direction flag
  3473                                  		mov si,offset crlf_msg
  3474                                  		call cwritestr
  3475                                  		mov bx,sp
  3476                                  		add bx,byte 26
  3477                                  		mov si,offset regnames
  3478                                  		mov cx,2		; 2*7 registers to dump
  3479                                  dump_line:	push cx
  3480                                  		mov cx,7		; 7 registers per line
  3481                                  dump_reg:	push cx
  3482                                  		mov cx,4		; 4 characters/register name
  3483                                  wr_reg_name:	lodsb
  3484                                  		call writechr
  3485                                  		loop wr_reg_name
  3486                                  		mov ax,ss:[bx]
  3487                                  		dec bx
  3488                                  		dec bx
  3489                                  		call writehex
  3490                                  		pop cx
  3491                                  		loop dump_reg
  3492                                  		mov al,0Dh		; <CR>
  3493                                  		call writechr
  3494                                  		mov al,0Ah		; <LF>
  3495                                  		call writechr
  3496                                  		pop cx
  3497                                  		loop dump_line
  3498                                  		pop gs
  3499                                  		pop fs
  3500                                  		pop es
  3501                                  		pop ds
  3502                                  		popa			; Restore the remainder
  3503                                  		popf			; Restore flags
  3504                                  		ret
  3505                                  dumpregs	endp
  3506                                  
  3507                                  regnames	db ' IP: FL: AX: CX: DX: BX: SP: BP: SI: DI: DS: ES: FS: GS:'
  3508                                  
  3509                                  ;
  3510                                  ; writehex:	Writes a 16-bit hexadecimal number (in AX)
  3511                                  ;
  3512                                  writehex	proc near
  3513                                  		push bx
  3514                                  		push cx
  3515                                  		mov cx,4		; 4 numbers
  3516                                  write_hexdig:	xor bx,bx
  3517                                  		push cx
  3518                                  		mov cx,4		; 4 bits/digit
  3519                                  xfer_digit:	shl ax,1
  3520                                  		rcl bx,1
  3521                                  		loop xfer_digit
  3522                                  		push ax
  3523                                  		mov ax,bx
  3524                                  		or al,'0'
  3525                                  		cmp al,'9'
  3526                                  		jna ok_digit
  3527                                  		add al,'A'-'0'-10
  3528                                  ok_digit:	call writechr
  3529                                  		pop ax
  3530                                  		pop cx
  3531                                  		loop write_hexdig
  3532                                  		pop cx
  3533                                  		pop bx
  3534                                  		ret
  3535                                  writehex	endp
  3536                                  
  3537                                  debug_magic	dw 0D00Dh
  3538                                  
  3539                                  %endif ; debug
  3540                                  ;
  3541                                  ; mangle_name: Mangle a DOS filename pointed to by DS:SI into a buffer pointed
  3542                                  ;	       to by ES:DI; ends on encountering any whitespace
  3543                                  ;
  3544                                  
  3545                                  mangle_name:
  3546 000013FC B90B00                  		mov cx,11			; # of bytes to write
  3547                                  mn_loop:
  3548 000013FF AC                      		lodsb
  3549 00001400 3C20                    		cmp al,' '			; If control or space, end
  3550 00001402 762A                    		jna mn_end
  3551 00001404 3C2E                    		cmp al,'.'			; Period -> space-fill
  3552 00001406 740C                    		je mn_is_period
  3553 00001408 3C61                    		cmp al,'a'
  3554 0000140A 721F                    		jb mn_not_lower
  3555 0000140C 3C7A                    		cmp al,'z'
  3556 0000140E 770E                    		ja mn_not_uslower
  3557 00001410 2C20                    		sub al,020h
  3558 00001412 EB17                    		jmp short mn_not_lower
  3559 00001414 B020                    mn_is_period:	mov al,' '			; We need to space-fill
  3560 00001416 83F903                  mn_period_loop: cmp cx,3			; If <= 3 characters left
  3561 00001419 76E4                    		jbe mn_loop			; Just ignore it
  3562 0000141B AA                      		stosb				; Otherwise, write a period
  3563 0000141C E2F8                    		loop mn_period_loop		; Dec CX and (always) jump
  3564 0000141E 3C81                    mn_not_uslower: cmp al,ucase_low
  3565 00001420 7209                    		jb mn_not_lower
  3566 00001422 3CA4                    		cmp al,ucase_high
  3567 00001424 7705                    		ja mn_not_lower
  3568 00001426 BB[B213]                		mov bx,ucase_tab-ucase_low
  3569 00001429 2ED7                                    cs xlatb
  3570 0000142B AA                      mn_not_lower:	stosb
  3571 0000142C E2D1                    		loop mn_loop			; Don't continue if too long
  3572                                  mn_end:
  3573 0000142E B020                    		mov al,' '			; Space-fill name
  3574 00001430 F3AA                    		rep stosb			; Doesn't do anything if CX=0
  3575 00001432 C3                      		ret				; Done
  3576                                  
  3577                                  ;
  3578                                  ; Upper-case table for extended characters; this is technically code page 865,
  3579                                  ; but code page 437 users will probably not miss not being able to use the
  3580                                  ; cent sign in kernel images too much :-)
  3581                                  ;
  3582                                  ; The table only covers the range 129 to 164; the rest we can deal with.
  3583                                  ;
  3584                                  ucase_low	equ 129
  3585                                  ucase_high	equ 164
  3586 00001433 9A90418E418F804545-     ucase_tab	db 154, 144, 'A', 142, 'A', 143, 128, 'EEEIII'
  3586 0000143C 45494949           
  3587 00001440 8E8F9092924F994F55-     		db 142, 143, 144, 146, 146, 'O', 153, 'OUUY', 153, 154
  3587 00001449 5559999A           
  3588 0000144D 9D9C9D9E9F41494F55-     		db 157, 156, 157, 158, 159, 'AIOU', 165
  3588 00001456 A5                 
  3589                                  
  3590                                  ;
  3591                                  ; unmangle_name: Does the opposite of mangle_name; converts a DOS-mangled
  3592                                  ;                filename to the conventional representation.  This is needed
  3593                                  ;                for the BOOT_IMAGE= parameter for the kernel.
  3594                                  ;                NOTE: A 13-byte buffer is mandatory, even if the string is
  3595                                  ;                known to be shorter.
  3596                                  ;
  3597                                  ;                DS:SI -> input mangled file name
  3598                                  ;                ES:DI -> output buffer
  3599                                  ;
  3600                                  ;                On return, DI points to the first byte after the output name,
  3601                                  ;                which is set to a null byte.
  3602                                  ;
  3603                                  unmangle_name:
  3604 00001457 56                                      push si                 ; Save pointer to original name
  3605 00001458 B90800                                  mov cx,8
  3606 0000145B 89FD                                    mov bp,di
  3607 0000145D AC                      un_copy_body:   lodsb
  3608 0000145E E82600                                  call lower_case
  3609 00001461 AA                                      stosb
  3610 00001462 3C20                                    cmp al,' '
  3611 00001464 7602                                    jbe un_cb_space
  3612 00001466 89FD                                    mov bp,di               ; Position of last nonblank+1
  3613 00001468 E2F3                    un_cb_space:    loop un_copy_body
  3614 0000146A 89EF                                    mov di,bp
  3615 0000146C B02E                                    mov al,'.'              ; Don't save
  3616 0000146E AA                                      stosb
  3617 0000146F B90300                                  mov cx,3
  3618 00001472 AC                      un_copy_ext:    lodsb
  3619 00001473 E81100                                  call lower_case
  3620 00001476 AA                                      stosb
  3621 00001477 3C20                                    cmp al,' '
  3622 00001479 7602                                    jbe un_ce_space
  3623 0000147B 89FD                                    mov bp,di
  3624 0000147D E2F3                    un_ce_space:    loop un_copy_ext
  3625 0000147F 89EF                                    mov di,bp
  3626 00001481 26C60500                                mov byte [es:di], 0
  3627 00001485 5E                                      pop si
  3628 00001486 C3                                      ret
  3629                                  
  3630                                  ;
  3631                                  ; lower_case: Lower case a character in AL
  3632                                  ;
  3633                                  lower_case:
  3634 00001487 3C41                                    cmp al,'A'
  3635 00001489 7216                                    jb lc_ret
  3636 0000148B 3C5A                                    cmp al,'Z'
  3637 0000148D 7703                                    ja lc_1
  3638 0000148F 0C20                                    or al,20h
  3639 00001491 C3                                      ret
  3640 00001492 3C80                    lc_1:           cmp al,lcase_low
  3641 00001494 720B                                    jb lc_ret
  3642 00001496 3CA5                                    cmp al,lcase_high
  3643 00001498 7707                                    ja lc_ret
  3644 0000149A 53                                      push bx
  3645 0000149B BB[2214]                                mov bx,lcase_tab-lcase_low
  3646 0000149E 2ED7                                   	cs xlatb
  3647 000014A0 5B                                      pop bx
  3648 000014A1 C3                      lc_ret:         ret
  3649                                  
  3650                                  ; ----------------------------------------------------------------------------------
  3651                                  ;  Begin data section
  3652                                  ; ----------------------------------------------------------------------------------
  3653                                  
  3654                                  CR		equ 13		; Carriage Return
  3655                                  LF		equ 10		; Line Feed
  3656                                  FF		equ 12		; Form Feed
  3657                                  BS		equ  8		; Backspace
  3658                                  
  3659                                  ;
  3660                                  ; Lower-case table for codepage 865
  3661                                  ;
  3662                                  lcase_low       equ 128
  3663                                  lcase_high      equ 165
  3664 000014A2 878182838485868788-     lcase_tab       db 135, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138
  3664 000014AB 898A               
  3665 000014AD 8B8C8D848682919193-                     db 139, 140, 141, 132, 134, 130, 145, 145, 147, 148, 149
  3665 000014B6 9495               
  3666 000014B8 96979894819B9C9B9E-                     db 150, 151, 152, 148, 129, 155, 156, 155, 158, 159, 160
  3666 000014C1 9FA0               
  3667 000014C3 A1A2A3A4A4                              db 161, 162, 163, 164, 164
  3668                                  
  3669 000014C8 20436F707972696768-     copyright_str   db ' Copyright (C) 1994-', year, ' H. Peter Anvin'
  3669 000014D1 742028432920313939-
  3669 000014DA 342D3230303020482E-
  3669 000014E3 20506574657220416E-
  3669 000014EC 76696E             
  3670 000014EF 0D0A00                  		db CR, LF, 0
  3671 000014F2 626F6F743A2000          boot_prompt	db 'boot: ', 0
  3672 000014F9 08200800                wipe_char	db 08h, ' ', 08h, 0
  3673 000014FD 436F756C64206E6F74-     err_notfound	db 'Could not find kernel image: ',0
  3673 00001506 2066696E64206B6572-
  3673 0000150F 6E656C20696D616765-
  3673 00001518 3A2000             
  3674 0000151B 0D0A496E76616C6964-     err_notkernel	db CR, LF, 'Invalid or corrupt kernel image.', CR, LF, 0
  3674 00001524 206F7220636F727275-
  3674 0000152D 7074206B65726E656C-
  3674 00001536 20696D6167652E0D0A-
  3674 0000153F 00                 
  3675 00001540 497420617070656172-     err_not386	db 'It appears your computer uses a 286 or lower CPU.'
  3675 00001549 7320796F757220636F-
  3675 00001552 6D7075746572207573-
  3675 0000155B 657320612032383620-
  3675 00001564 6F72206C6F77657220-
  3675 0000156D 4350552E           
  3676 00001571 0D0A                    		db CR, LF
  3677 00001573 596F752063616E6E6F-     		db 'You cannot run Linux unless you have a 386 or higher CPU'
  3677 0000157C 742072756E204C696E-
  3677 00001585 757820756E6C657373-
  3677 0000158E 20796F752068617665-
  3677 00001597 206120333836206F72-
  3677 000015A0 206869676865722043-
  3677 000015A9 5055               
  3678 000015AB 0D0A                    		db CR, LF
  3679 000015AD 696E20796F7572206D-     		db 'in your machine.  If you get this message in error, hold'
  3679 000015B6 616368696E652E2020-
  3679 000015BF 496620796F75206765-
  3679 000015C8 742074686973206D65-
  3679 000015D1 737361676520696E20-
  3679 000015DA 6572726F722C20686F-
  3679 000015E3 6C64               
  3680 000015E5 0D0A                    		db CR, LF
  3681 000015E7 646F776E2074686520-     		db 'down the Ctrl key while booting, and I will take your'
  3681 000015F0 4374726C206B657920-
  3681 000015F9 7768696C6520626F6F-
  3681 00001602 74696E672C20616E64-
  3681 0000160B 20492077696C6C2074-
  3681 00001614 616B6520796F7572   
  3682 0000161C 0D0A                    		db CR, LF
  3683 0000161E 776F726420666F7220-     		db 'word for it.', CR, LF, 0
  3683 00001627 69742E0D0A00       
  3684 0000162D 497420617070656172-     err_noram	db 'It appears your computer has less than 512K of low ("DOS")'
  3684 00001636 7320796F757220636F-
  3684 0000163F 6D7075746572206861-
  3684 00001648 73206C657373207468-
  3684 00001651 616E203531324B206F-
  3684 0000165A 66206C6F7720282244-
  3684 00001663 4F532229           
  3685 00001667 0D0A                    		db CR, LF
  3686 00001669 52414D2E20204C696E-     		db 'RAM.  Linux needs at least this amount to boot.  If you get'
  3686 00001672 7578206E6565647320-
  3686 0000167B 6174206C6561737420-
  3686 00001684 7468697320616D6F75-
  3686 0000168D 6E7420746F20626F6F-
  3686 00001696 742E2020496620796F-
  3686 0000169F 7520676574         
  3687 000016A4 0D0A                    		db CR, LF
  3688 000016A6 74686973206D657373-     		db 'this message in error, hold down the Ctrl key while'
  3688 000016AF 61676520696E206572-
  3688 000016B8 726F722C20686F6C64-
  3688 000016C1 20646F776E20746865-
  3688 000016CA 204374726C206B6579-
  3688 000016D3 207768696C65       
  3689 000016D9 0D0A                    		db CR, LF
  3690 000016DB 626F6F74696E672C20-     		db 'booting, and I will take your word for it.', CR, LF, 0
  3690 000016E4 616E6420492077696C-
  3690 000016ED 6C2074616B6520796F-
  3690 000016F6 757220776F72642066-
  3690 000016FF 6F722069742E0D0A00 
  3691 00001708 556E6B6E6F776E206B-     err_badcfg      db 'Unknown keyword in syslinux.cfg.', CR, LF, 0
  3691 00001711 6579776F726420696E-
  3691 0000171A 207379736C696E7578-
  3691 00001723 2E6366672E0D0A00   
  3692 0000172B 4D697373696E672070-     err_noparm      db 'Missing parameter in syslinux.cfg.', CR, LF, 0
  3692 00001734 6172616D6574657220-
  3692 0000173D 696E207379736C696E-
  3692 00001746 75782E6366672E0D0A-
  3692 0000174F 00                 
  3693 00001750 0D0A436F756C64206E-     err_noinitrd    db CR, LF, 'Could not find ramdisk image: ', 0
  3693 00001759 6F742066696E642072-
  3693 00001762 616D6469736B20696D-
  3693 0000176B 6167653A2000       
  3694 00001771 4E6F7420656E6F7567-     err_nohighmem   db 'Not enough memory to load specified kernel.', CR, LF, 0
  3694 0000177A 68206D656D6F727920-
  3694 00001783 746F206C6F61642073-
  3694 0000178C 706563696669656420-
  3694 00001795 6B65726E656C2E0D0A-
  3694 0000179E 00                 
  3695 0000179F 0D0A4B65726E656C20-     err_highload    db CR, LF, 'Kernel transfer failure.', CR, LF, 0
  3695 000017A8 7472616E7366657220-
  3695 000017B1 6661696C7572652E0D-
  3695 000017BA 0A00               
  3696 000017BC 43616E6E6F74206C6F-     err_oldkernel   db 'Cannot load a ramdisk with an old kernel image.'
  3696 000017C5 616420612072616D64-
  3696 000017CE 69736B207769746820-
  3696 000017D7 616E206F6C64206B65-
  3696 000017E0 726E656C20696D6167-
  3696 000017E9 652E               
  3697 000017EB 0D0A00                                  db CR, LF, 0
  3698 000017EE 3A20617474656D7074-     err_notdos	db ': attempted DOS system call', CR, LF, 0
  3698 000017F7 656420444F53207379-
  3698 00001800 7374656D2063616C6C-
  3698 00001809 0D0A00             
  3699 0000180C 434F4D424F4F542069-     err_comlarge	db 'COMBOOT image too large.', CR, LF, 0
  3699 00001815 6D61676520746F6F20-
  3699 0000181E 6C617267652E0D0A00 
  3700 00001827 496E76616C6964206F-     err_bootsec	db 'Invalid or corrupt boot sector image.', CR, LF, 0
  3700 00001830 7220636F7272757074-
  3700 00001839 20626F6F7420736563-
  3700 00001842 746F7220696D616765-
  3700 0000184B 2E0D0A00           
  3701 0000184F 0D0A41323020676174-     err_a20		db CR, LF, 'A20 gate not responding!', CR, LF, 0
  3701 00001858 65206E6F7420726573-
  3701 00001861 706F6E64696E67210D-
  3701 0000186A 0A00               
  3702 0000186C 0D0A426F6F74206661-     err_bootfailed	db CR, LF, 'Boot failed: please change disks and press '
  3702 00001875 696C65643A20706C65-
  3702 0000187E 617365206368616E67-
  3702 00001887 65206469736B732061-
  3702 00001890 6E6420707265737320 
  3703 00001899 61206B657920746F20-     		db 'a key to continue.', CR, LF, 0
  3703 000018A2 636F6E74696E75652E-
  3703 000018AB 0D0A00             
  3704 000018AE 2072656164792E0D0A-     ready_msg	db ' ready.', CR, LF, 0
  3704 000018B7 00                 
  3705 000018B8 4C6F6164696E672000      loading_msg     db 'Loading ', 0
  3706 000018C1 2E                      dotdot_msg      db '.'
  3707 000018C2 2E00                    dot_msg         db '.', 0
  3708 000018C4 2061626F727465642E      aborted_msg	db ' aborted.'			; Fall through to crlf_msg!
  3709 000018CD 0D0A00                  crlf_msg	db CR, LF, 0
  3710 000018D0 0D0C00                  crff_msg	db CR, FF, 0
  3711 000018D3 5359534C494E555843-     syslinux_cfg	db 'SYSLINUXCFG'
  3711 000018DC 4647               
  3712                                  ;
  3713                                  ; Command line options we'd like to take a look at
  3714                                  ;
  3715                                  ; mem= and vga= are handled as normal 32-bit integer values
  3716 000018DE 696E697472643D          initrd_cmd	db 'initrd='
  3717                                  initrd_cmd_len	equ 7
  3718                                  ;
  3719                                  ; Config file keyword table
  3720                                  ;
  3721 000018E5 90                      		align 2
  3722 000018E6 6170                    keywd_table	db 'ap' ; append
  3723 000018E8 6465                    		db 'de' ; default
  3724 000018EA 7469                    		db 'ti' ; timeout
  3725 000018EC 666F                    		db 'fo'	; font
  3726 000018EE 6B62                    		db 'kb' ; kbd
  3727 000018F0 6469                    		db 'di' ; display
  3728 000018F2 7072                    		db 'pr' ; prompt
  3729 000018F4 6C61                    		db 'la' ; label
  3730 000018F6 696D                                    db 'im' ; implicit
  3731 000018F8 6B65                    		db 'ke' ; kernel
  3732 000018FA 7365                    		db 'se' ; serial
  3733 000018FC 6631                    		db 'f1' ; F1
  3734 000018FE 6632                    		db 'f2' ; F2
  3735 00001900 6633                    		db 'f3' ; F3
  3736 00001902 6634                    		db 'f4' ; F4
  3737 00001904 6635                    		db 'f5' ; F5
  3738 00001906 6636                    		db 'f6' ; F6
  3739 00001908 6637                    		db 'f7' ; F7
  3740 0000190A 6638                    		db 'f8' ; F8
  3741 0000190C 6639                    		db 'f9' ; F9
  3742 0000190E 6630                    		db 'f0' ; F10
  3743 00001910 0000                    		dw 0
  3744                                  ;
  3745                                  ; Extensions to search for (in *reverse* order).  Note that the last
  3746                                  ; (lexically first) entry in the table is a placeholder for the original
  3747                                  ; extension, needed for error messages.  The exten_table is shifted so
  3748                                  ; the table is 1-based; this is because a "loop" cx is used as index.
  3749                                  ;
  3750                                  exten_table:
  3751 00001912 00000000                OrigKernelExt:	dd 0			; Original extension
  3752 00001916 434F4D00                		db 'COM',0		; COMBOOT (same as DOS)
  3753 0000191A 42532000                		db 'BS ',0		; Boot Sector 
  3754 0000191E 42535300                		db 'BSS',0		; Boot Sector (add superblock)
  3755 00001922 43425400                		db 'CBT',0		; COMBOOT (specific)
  3756                                  
  3757                                  exten_count	equ (($-exten_table) >> 2) - 1	; Number of alternates
  3758                                  ;
  3759                                  ; Misc initialized (data) variables
  3760                                  ;
  3761 00001926 0000                    AppendLen       dw 0                    ; Bytes in append= command
  3762 00001928 0000                    KbdTimeOut      dw 0                    ; Keyboard timeout (if any)
  3763 0000192A 0000                    FKeyMap		dw 0			; Bitmap for F-keys loaded
  3764 0000192C 0090                    CmdLinePtr	dw cmd_line_here	; Command line advancing pointer
  3765                                  initrd_flag	equ $
  3766 0000192E 0000                    initrd_ptr	dw 0			; Initial ramdisk pointer/flag
  3767 00001930 0000                    VKernelCtr	dw 0			; Number of registered vkernels
  3768 00001932 0000                    ForcePrompt	dw 0			; Force prompt
  3769 00001934 0100                    AllowImplicit   dw 1                    ; Allow implicit kernels
  3770 00001936 0000                    SerialPort	dw 0			; Serial port base (or 0 for no serial port)
  3771                                  ;
  3772                                  ; Stuff for the command line; we do some trickery here with equ to avoid
  3773                                  ; tons of zeros appended to our file and wasting space
  3774                                  ;
  3775 00001938 6C696E757820            linuxauto_cmd	db 'linux '
  3776 0000193E 6175746F00              auto_cmd	db 'auto',0
  3777                                  linuxauto_len   equ $-linuxauto_cmd
  3778                                  auto_len        equ $-auto_cmd
  3779 00001943 424F4F545F494D4147-     boot_image      db 'BOOT_IMAGE='
  3779 0000194C 453D               
  3780                                  boot_image_len  equ $-boot_image
  3781 0000194E 00<rep 2h>                              align 4, db 0		; For the good of REP MOVSD
  3782                                  command_line	equ $
  3783                                  default_cmd	equ $+(max_cmd_len+2)
  3784                                  ldlinux_end	equ default_cmd+(max_cmd_len+1)
  3785                                  kern_cmd_len    equ ldlinux_end-command_line
  3786                                  ldlinux_len	equ ldlinux_end-ldlinux_magic
  3787                                  ;
  3788                                  ; Put the getcbuf right after the code, aligned on a sector boundary
  3789                                  ;
  3790                                  end_of_code	equ (ldlinux_end-bootsec)+7C00h
  3791                                  getcbuf		equ (end_of_code + 511) & 0FE00h
